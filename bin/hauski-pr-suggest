#!/usr/bin/env bash
set -euo pipefail
# Postet aus dem letzten HausKI-Report kopierbare Patch-Schnipsel in PR-Kommentare.
# Optional: Gist mit .patch anlegen und verlinken.
# Steuerung:
#   HAUSKI_PR_ALL=1     ‚Üí alle offenen PRs (sonst nur der √§lteste)
#   HAUSKI_PR_GIST=1    ‚Üí zus√§tzlich Gist mit Patch hochladen (gh gist create)
#   HAUSKI_PR_TITLE=‚Ä¶   ‚Üí Titelpr√§fix f√ºr Kommentar

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || true)"
[ -n "$ROOT" ] || {
	echo "‚è≠Ô∏è  kein Git-Repo"
	exit 0
}
REPO="$(basename "$ROOT")"
REPORT_DIR="$HOME/sichter/review/$REPO"
LAST="$(ls -1t "$REPORT_DIR"/*-review.md 2>/dev/null | head -n1 || true)"
[ -n "$LAST" ] || {
	echo "‚ÑπÔ∏è  kein Report"
	exit 0
}

command -v gh >/dev/null 2>&1 || {
	echo "‚ö†Ô∏è  gh fehlt"
	exit 0
}

# 1) Patch/Diff-Bl√∂cke extrahieren
TMP="$(mktemp)"
SUG_DIR="$(mktemp -d)"
cleanup() {
	rm -f "$TMP"
	rm -rf "$SUG_DIR"
}
trap cleanup EXIT
awk '
  BEGIN{IN=0}
  /^```(patch|diff)/{IN=1; next}
  /^```[[:space:]]*$/ && IN==1 {IN=0; print ""; next}
  IN==1 {print}
' "$LAST" >"$TMP"

if [ ! -s "$TMP" ]; then
	echo "‚ÑπÔ∏è  kein diff/patch Block im Report."
	exit 0
fi

# 2) Patch ggf. k√ºrzen / splitten in Schnipsel ‚â§ 6000 Zeichen pro Kommentar
#    (GitHub Kommentar-Limit ~64k; wir bleiben konservativ)
MAX=6000
awk -v max="$MAX" -v dir="$SUG_DIR" '
  BEGIN{buf="";len=0;idx=1}
  {
    line=$0"\n"; L=length(line);
    if (len+L > max && len>0) {
      fn=dir "/chunk-" idx ".diff"; print buf > fn; close(fn); idx++; buf=line; len=L;
    } else { buf=buf line; len+=L; }
  }
  END{
    if (len>0) { fn=dir "/chunk-" idx ".diff"; print buf > fn; close(fn); }
  }
' "$TMP"
mapfile -t PATCH_FILES < <(ls -1 "$SUG_DIR"/chunk-*.diff 2>/dev/null || true)
if [ ${#PATCH_FILES[@]} -eq 0 ]; then
	echo "‚ÑπÔ∏è  Patch leer."
	exit 0
fi

# 3) Optional: Gist mit Gesamtsammlung
GIST_URL=""
if [ "${HAUSKI_PR_GIST:-0}" = "1" ]; then
	cp "$TMP" "$SUG_DIR/all.patch"
	GIST_URL="$(gh gist create -p -d "HausKI suggestions for $REPO ($(date +%F %T))" "$SUG_DIR/all.patch" 2>/dev/null || true)"
fi

# 4) Kontext vorbereiten
HEAD_MD="$(sed -n '1,80p' "$LAST")"

if git rev-parse --verify HEAD >/dev/null 2>&1; then
	if git diff --quiet --ignore-submodules HEAD; then
		AUTO_STATE="clean"
	else
		AUTO_STATE="dirty"
	fi
else
	if [ -z "$(git status --porcelain 2>/dev/null)" ]; then
		AUTO_STATE="clean"
	else
		AUTO_STATE="dirty"
	fi
fi

AUTO_NOTE="‚ÑπÔ∏è Auto-apply deaktiviert"
if [ "${HAUSKI_AUTO_APPLY:-0}" = "1" ]; then
	if [ "$AUTO_STATE" = "clean" ]; then
		if git rev-parse --verify HEAD >/dev/null 2>&1; then
			HEAD_HASH="$(git rev-parse --short HEAD 2>/dev/null || echo "?")"
			HEAD_MSG="$(git log -1 --pretty=%s 2>/dev/null || echo "")"
		else
			HEAD_HASH="(kein HEAD)"
			HEAD_MSG=""
		fi
		if [ "${HAUSKI_AUTO_COMMIT:-0}" = "1" ]; then
			AUTO_NOTE="‚úÖ Auto-apply & Commit erledigt (HEAD $HEAD_HASH ‚Äì $HEAD_MSG)"
		else
			AUTO_NOTE="‚úÖ Auto-apply angewendet (HEAD $HEAD_HASH ‚Äì $HEAD_MSG)"
		fi
	else
		AUTO_NOTE="‚ö†Ô∏è Auto-apply aktiv, √Ñnderungen noch lokal (siehe Patch)"
	fi
fi

APPLY_HINT="hauski-auto-here"
[ -x "$HOME/sichter/bin/hauski-auto-here" ] || APPLY_HINT="hauski-apply"

build_body() {
	local title="$1"
	local body_file="$(mktemp)"

	{
		echo "### $title"
		echo "- Repo: \`$REPO\`"
		echo "- Report: \`$(basename "$LAST")\`"
		echo "- Auto-Apply: $AUTO_NOTE"
		if [ -n "$GIST_URL" ]; then
			echo "- Patch-Gist: $GIST_URL"
		fi
		echo "- Anwenden: \`$APPLY_HINT\` oder \`git apply --3way\`"
		echo
		echo "<details><summary>Report-Auszug</summary>"
		echo
		echo '\`\`\`md'
		printf '%s\n' "$HEAD_MD"
		echo '\`\`\`'
		echo
		echo "</details>"
		echo
		local idx=1
		for f in "${PATCH_FILES[@]}"; do
			[ -s "$f" ] || continue
			echo "<details><summary>Patch $idx</summary>"
			echo
			echo '\`\`\`diff'
			cat "$f"
			echo '\`\`\`'
			echo
			echo "</details>"
			echo
			idx=$((idx + 1))
		done
	} >"$body_file"

	echo "$body_file"
}

# 5) Offene PRs bestimmen
JSN="$(gh pr list --state open --limit 100 --json number,createdAt,title 2>/dev/null || echo '[]')"
[ -n "$JSN" ] || {
	echo "‚ÑπÔ∏è  keine offenen PRs"
	exit 0
}

# Gew√ºnschte Ziel-PRs aufbauen (Env: HAUSKI_PR_NUMBER="12,34")
declare -a PR_LIST=()
if [ -n "${HAUSKI_PR_NUMBER:-}" ]; then
	IFS=',' read -ra REQ_PR <<<"${HAUSKI_PR_NUMBER// /}"
	for pr in "${REQ_PR[@]}"; do
		[ -n "$pr" ] || continue
		if printf '%s' "$JSN" | jq -e --arg pr "$pr" 'map(.number|tostring)|index($pr)' >/dev/null 2>&1; then
			PR_LIST+=("$pr")
		else
			echo "‚ÑπÔ∏è  PR #$pr nicht gefunden oder nicht offen" >&2
		fi
	done
	[ ${#PR_LIST[@]} -gt 0 ] || {
		echo "‚ÑπÔ∏è  keine passenden PR-Ziele" >&2
		exit 0
	}
elif [ "${HAUSKI_PR_ALL:-0}" = "1" ]; then
	mapfile -t PR_LIST < <(printf '%s' "$JSN" | jq -r 'sort_by(.createdAt)|.[].number')
else
	one="$(printf '%s' "$JSN" | jq -r 'sort_by(.createdAt)|.[0].number // empty')"
	[ -n "$one" ] && PR_LIST=("$one")
fi

[ ${#PR_LIST[@]} -gt 0 ] || {
	echo "‚ÑπÔ∏è  kein offener PR"
	exit 0
}

post_one() {
	local pr="$1"
	local title="${HAUSKI_PR_TITLE:-HausKI Auto-Vorschl√§ge}"
	local body_file
	body_file="$(build_body "$title")"
	gh pr comment "$pr" --body-file "$body_file" >/dev/null || true
	rm -f "$body_file"
	echo "üí¨ PR #$pr: Vorschl√§ge gepostet."
}

for pr in "${PR_LIST[@]}"; do
	post_one "$pr"
done
