#!/usr/bin/env bash
set -euo pipefail

# Source the shared library
# shellcheck source=lib/common.sh
source "$(dirname "$0")/../lib/common.sh"
parse_common_args "$@"

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [ -z "$ROOT" ]; then
  echo "â­ï¸  kein Git-Repo"
  exit 0
fi
REPO="$(basename "$ROOT")"
if ! validate_name_non_fatal "$REPO"; then
  echo "Error: Invalid repo name." >&2
  exit 1
fi
REPORT_DIR="${HOME}/sichter/review/${REPO}"
# Portabel: neueste Datei anhand ls -t; robust mit -print0/xargs -0 (macOS & Linux)
LAST="$(find "${REPORT_DIR}" -maxdepth 1 -name '*-review.md' -type f -print0 | xargs -0 ls -1t 2>/dev/null | head -n1 || true)"
if [ -z "$LAST" ]; then
  echo "â„¹ï¸  kein Report"
  exit 0
fi

cd "${ROOT}"
TMP="$(mktemp)"
trap 'rm -f "${TMP}"' EXIT
EXTRACTED=0

# Patch/Diff-Fences robust extrahieren (Variable nicht 'in' nennen)
awk '
  BEGIN{INSIDE=0}
  /^```(patch|diff)/{INSIDE=1; next}
  /^```[[:space:]]*$/ && INSIDE==1 {INSIDE=0; print ""; next}
  INSIDE==1 {print}
' "${LAST}" >"${TMP}"

if [ -s "${TMP}" ]; then
  EXTRACTED=1
  echo "ðŸ§© Patches gefunden â€“ apply (3-way)â€¦"
  if git apply --3way --index "${TMP}"; then
    echo "âœ… Patches angewendet."
  else
    echo "âš ï¸  Patch-Apply teilweise fehlgeschlagen (Conflicts mÃ¶glich)."
  fi
else
  echo "â„¹ï¸  Keine \`\`\`patch/\`\`\`diff BlÃ¶cke im Report."
fi

# Auto-Fixer (best effort, nur wenn ein Patch vorhanden war)
if [ "$EXTRACTED" -eq 1 ]; then
  if command -v cargo >/dev/null 2>&1; then
    cargo fmt || true
    cargo clippy --fix --allow-dirty --allow-staged || true
  fi
  if command -v shfmt >/dev/null 2>&1; then
    shfmt -w . || true
  fi
fi

git status --short || true
