#!/usr/bin/env bash
ghjson(){ ghjson -H "Accept: application/vnd.github+json" "$@"; }
#!/usr/bin/env bash
set -euo pipefail

STATE_FILE="$HOME/sichter/review/pr-reviewed.json"
LOG="$HOME/sichter/logs/pr-watch.log"
TMP_DIR="$HOME/sichter/tmp"
LOCK_FILE="$TMP_DIR/pr-watch.lock"
INTERVAL="${HAUSKI_PR_INTERVAL:-300}"
REMOTE_BASE="${HAUSKI_REMOTE_BASE:-$HOME/sichter/repos}"
WORKTREE_BASE="${HAUSKI_WORKTREE_BASE:-$HOME/sichter/pr-worktrees}"
FORCE_FLAGS_DEFAULT="${HAUSKI_PR_FORCE_FLAGS:-${HAUSKI_FORCE_FLAGS:-}}"
PR_TIMEOUT="${HAUSKI_PR_TIMEOUT:-20m}"
REMOTE_CLONE_FLAGS="${HAUSKI_REMOTE_CLONE_FLAGS:---filter=blob:none}"
DEFAULT_BRANCH_PREFIX="hauski/pr"
SCOPE_RAW="${HAUSKI_PR_SCOPE:-auto}"
ORG="${HAUSKI_ORG:-}"
USER_NAME="${HAUSKI_USER:-}"
INCLUDE_AUTHORED="${HAUSKI_INCLUDE_AUTHORED:-1}"

[ -n "$FORCE_FLAGS_DEFAULT" ] || FORCE_FLAGS_DEFAULT="--heavy"

scope_has() {
  local needle="$1"
  case "$SCOPE_RAW" in
    auto)
      case "$needle" in
        org) [ -n "$ORG" ] ;;
        user) [ -n "$USER_NAME" ] ;;
        *) return 1 ;;
      esac
    ;;
    both|all) return 0 ;;
    org) [ "$needle" = "org" ] ;;
    user) [ "$needle" = "user" ] ;;
    *) return 1 ;;
  esac
}

if ! scope_has org && ! scope_has user && [ "${INCLUDE_AUTHORED:-0}" != "1" ]; then
  echo "âš ï¸  weder ORG noch USER konfiguriert â€“ bitte HAUSKI_ORG/HAUSKI_USER setzen." | tee -a "$LOG"
  exit 1
fi

mkdir -p "$REMOTE_BASE" "$WORKTREE_BASE" "$(dirname "$STATE_FILE")" "$TMP_DIR" "$(dirname "$LOG")"
[ -f "$STATE_FILE" ] || echo '{}' >"$STATE_FILE"

exec 200>"$LOCK_FILE"
if ! flock -n 200; then
  echo "âš ï¸ pr-watch bereits aktiv" | tee -a "$LOG"
  exit 0
fi

command -v gh >/dev/null 2>&1 || { echo "âš ï¸  gh fehlt" | tee -a "$LOG"; exit 1; }
command -v git >/dev/null 2>&1 || { echo "âš ï¸  git fehlt" | tee -a "$LOG"; exit 1; }
command -v jq >/dev/null 2>&1 || { echo "âš ï¸  jq fehlt" | tee -a "$LOG"; exit 1; }

log(){
  printf '%s %s\n' "$(date '+%F %T')" "$*" | tee -a "$LOG"
}

read_state(){
  local key="$1"
  jq -e --arg key "$key" -r 'try .[$key].sha catch ""' "$STATE_FILE"
}

write_state(){
  local key="$1" sha="$2"
  local ts tmp
  ts="$(date '+%Y-%m-%dT%H:%M:%S')"
  tmp="$(mktemp)"
  if jq --arg key "$key" --arg sha "$sha" --arg ts "$ts" '
        (type=="object"? . : {})
        | .[$key] = {sha:$sha, ts:$ts}
      ' "$STATE_FILE" >"$tmp"; then
    mv "$tmp" "$STATE_FILE"
  else
    rm -f "$tmp"
  fi
}

ensure_clone(){
  local full="$1"
  local owner="${full%/*}"
  local repo="${full#*/}"
  local target="$REMOTE_BASE/$owner/$repo"
  if [ ! -d "$target/.git" ]; then
    mkdir -p "$REMOTE_BASE/$owner"
    log "â¬‡ï¸  clone $full"
    if ! gh repo clone "$full" "$target" -- $REMOTE_CLONE_FLAGS >/dev/null 2>&1; then
      gh repo clone "$full" "$target" >/dev/null 2>&1 || return 1
    fi
  else
    git -C "$target" remote update --prune >/dev/null 2>&1 || true
  fi
  git -C "$target" fetch --prune origin >/dev/null 2>&1 || true
  printf '%s' "$target"
}

cleanup_pr_workspace(){
  local repo_path="$1" worktree="$2" branch="$3"
  git -C "$repo_path" worktree remove --force "$worktree" >/dev/null 2>&1 || true
  rm -rf "$worktree"
  git -C "$repo_path" branch -D "$branch" >/dev/null 2>&1 || true
  git -C "$repo_path" worktree prune >/dev/null 2>&1 || true
}

list_repos_for_scope(){
  declare -A seen
  if scope_has org && [ -n "$ORG" ]; then
    while read -r repo; do
      [ -n "$repo" ] || continue
      if [ -z "${seen[$repo]:-}" ]; then
        printf '%s\n' "$repo"
        seen[$repo]=1
      fi
    done < <(ghjson --paginate "/orgs/$ORG/repos" -f per_page=100 --jq '.[ ]? | select((.archived|not) and (.disabled|not)) | .full_name')
  fi
  if scope_has user && [ -n "$USER_NAME" ]; then
    while read -r repo; do
      [ -n "$repo" ] || continue
      if [ -z "${seen[$repo]:-}" ]; then
        printf '%s\n' "$repo"
        seen[$repo]=1
      fi
    done < <(ghjson --paginate "/users/$USER_NAME/repos" -f per_page=100 --jq '.[ ]? | select((.archived|not) and (.disabled|not)) | .full_name')
  fi
  return 0
}

fetch_repo_prs(){
  local repo="$1"
  REPO="$repo" ghjson --silent --paginate "/repos/$repo/pulls" -f state=open -f per_page=50 \
    --jq '.[ ]?
      | select(.head.repo != null)
      | {
          repo:env.REPO,
          number:.number,
          headSha:.head.sha,
          headRef:(.head.ref // ""),
          updatedAt:.updated_at,
          draft:(.draft // false),
          maintainerCanModify:(.maintainer_can_modify // false),
          headRepo:(.head.repo.full_name // env.REPO),
          headClone:(.head.repo.clone_url // ""),
          headSsh:(.head.repo.ssh_url // ""),
          headOwner:(.head.repo.owner.login // ""),
          author:(.user.login // ""),
          baseRepo:(.base.repo.full_name // env.REPO)
        } | @json'
}

fetch_authored_prs(){
  local user="$1"
  [ -n "$user" ] || return 0
  [ "${INCLUDE_AUTHORED:-0}" = "1" ] || return 0
  ghjson --paginate /search/issues -f per_page=50 --raw-field q="is:pr state:open author:$user" --jq '.items[] | {repo:(.repository_url | sub("https://api.github.com/repos/"; "")), number:.number} | @json' \
    | while read -r row; do
        local repo number
        repo="$(printf '%s' "$row" | jq -r 'fromjson | .repo')"
        number="$(printf '%s' "$row" | jq -r 'fromjson | .number')"
        [ -n "$repo" ] || continue
        [ "$repo" = "null" ] && continue
        ghjson --silent "/repos/$repo/pulls/$number" \
          --jq '{
              repo:(.base.repo.full_name // "'$repo'"),
              number:.number,
              headSha:.head.sha,
              headRef:(.head.ref // ""),
              updatedAt:.updated_at,
              draft:(.draft // false),
              maintainerCanModify:(.maintainer_can_modify // false),
              headRepo:(.head.repo.full_name // ""),
              headClone:(.head.repo.clone_url // ""),
              headSsh:(.head.repo.ssh_url // ""),
              headOwner:(.head.repo.owner.login // ""),
              author:(.user.login // ""),
              baseRepo:(.base.repo.full_name // "")
            } | @json'
      done
}

fetch_open_prs(){
  declare -A seen
  list_repos_for_scope |
    while read -r repo; do
      [ -n "$repo" ] || continue
      fetch_repo_prs "$repo"
    done |
    while read -r row; do
      [ -n "$row" ] || continue
      local key
      key="$(printf '%s' "$row" | jq -r 'fromjson | (.repo + "#" + (.number|tostring))')"
      [ -n "$key" ] || continue
      if [ -z "${seen[$key]:-}" ]; then
        printf '%s\n' "$row"
        seen[$key]=1
      fi
    done

  if [ -n "$USER_NAME" ]; then
    fetch_authored_prs "$USER_NAME" |
      while read -r row; do
        [ -n "$row" ] || continue
        local key
        key="$(printf '%s' "$row" | jq -r 'fromjson | (.repo + "#" + (.number|tostring))')"
        [ -n "$key" ] || continue
        if [ -z "${seen[$key]:-}" ]; then
          printf '%s\n' "$row"
          seen[$key]=1
        fi
      done
  fi
}

review_pr(){
  local repo_full="$1"
  local number="$2"
  local sha="$3"
  local head_ref="$4"
  local head_repo="$5"
  local head_clone="$6"
  local head_ssh="$7"
  local maint_can_modify="$8"
  local author="$9"
  local repo_path worktree branch worktree_parent remote_name head_remote_url allow_push initial_commit new_commit push_succeeded

  repo_path="$(ensure_clone "$repo_full")" || { log "âš ï¸  clone fehlgeschlagen fÃ¼r $repo_full"; return 1; }
  branch="${DEFAULT_BRANCH_PREFIX}-${number}"
  worktree_parent="$WORKTREE_BASE/${repo_full%/*}"
  worktree="$WORKTREE_BASE/$repo_full/pr-$number"
  mkdir -p "$worktree_parent" "$(dirname "$worktree")"

  cleanup_pr_workspace "$repo_path" "$worktree" "$branch"

  if ! git -C "$repo_path" fetch origin "pull/$number/head:$branch" >/dev/null 2>&1; then
    log "âš ï¸  fetch fehlgeschlagen: $repo_full#$number"
    return 1
  fi

  if ! git -C "$repo_path" worktree add --force "$worktree" "$branch" >/dev/null 2>&1; then
    log "âš ï¸  worktree fehlgeschlagen: $repo_full#$number"
    return 1
  fi

  touch "$worktree/sichter-enable"
  remote_name="hauski-head-$number"
  head_remote_url="${head_ssh:-}"
  [ -n "$head_remote_url" ] || head_remote_url="$head_clone"

  allow_push=0
  if [ "${HAUSKI_REMOTE_AUTO_COMMIT:-0}" = "1" ]; then
    if [ "$maint_can_modify" = "true" ] || [ "$maint_can_modify" = "1" ]; then
      allow_push=1
    elif [ -n "$USER_NAME" ] && [ -n "$author" ] && [ "$USER_NAME" = "$author" ]; then
      allow_push=1
    elif [ -n "$USER_NAME" ] && [ -n "$head_repo" ] && printf '%s' "$head_repo" | grep -q "^$USER_NAME/"; then
      allow_push=1
    fi
  fi

  local remote_is_origin=0
  if [ -n "$head_repo" ] && [ "$head_repo" = "$repo_full" ]; then
    remote_name="origin"
    remote_is_origin=1
    if [ "$allow_push" -eq 0 ]; then
      allow_push=1
    fi
  fi

  if [ "$allow_push" -eq 1 ] && [ -n "$head_remote_url" ]; then
    if [ "$remote_is_origin" -eq 0 ]; then
      git -C "$repo_path" remote remove "$remote_name" >/dev/null 2>&1 || true
      if git -C "$repo_path" remote add "$remote_name" "$head_remote_url" >/dev/null 2>&1; then
        git -C "$repo_path" fetch "$remote_name" "$head_ref" >/dev/null 2>&1 || true
      else
        allow_push=0
      fi
    fi
  else
    allow_push=0
  fi

  initial_commit="$(git -C "$repo_path" rev-parse "$branch" 2>/dev/null || echo "")"
  local status=0
  local -a env_cmd
  env_cmd=(
    env
    HAUSKI_PR_NUMBER="$number"
    HAUSKI_PR_ALL=0
    HAUSKI_FORCE_FLAGS="$FORCE_FLAGS_DEFAULT"
    HAUSKI_PR_FORCE_FLAGS="$FORCE_FLAGS_DEFAULT"
    HAUSKI_AUTO_APPLY="${HAUSKI_REMOTE_AUTO_APPLY:-1}"
    HAUSKI_AUTO_COMMIT="${HAUSKI_REMOTE_AUTO_COMMIT:-1}"
    HAUSKI_AUTO_PR="${HAUSKI_REMOTE_AUTO_PR:-0}"
    HAUSKI_PR_HEAD_REF="$head_ref"
    HAUSKI_PR_HEAD_SHA="$sha"
  )
  if [ "$allow_push" -eq 1 ] && [ -n "$head_ref" ]; then
    env_cmd+=(
      HAUSKI_FORCE_PUSH_REMOTE="$remote_name"
      HAUSKI_FORCE_PUSH_REF="$head_ref"
      HAUSKI_FORCE_PUSH_SET_UPSTREAM=0
    )
  fi
  env_cmd+=(
    HAUSKI_FORCE_KEEP_BRANCH=1
    HAUSKI_PR_HEAD_REPO="$head_repo"
    HAUSKI_PR_HEAD_REMOTE_URL="$head_remote_url"
    timeout "$PR_TIMEOUT" "$HOME/sichter/hooks/post-run"
  )

  if ! (
    cd "$worktree"
    git reset --hard >/dev/null 2>&1 || true
    "${env_cmd[@]}"
  ); then
    status=1
  fi

  push_succeeded=0
  new_commit="$(git -C "$repo_path" rev-parse "$branch" 2>/dev/null || echo "")"
  if [ "$allow_push" -eq 1 ] && [ -n "$head_ref" ] && [ -n "$head_remote_url" ]; then
    if [ -n "$initial_commit" ] && [ -n "$new_commit" ] && [ "$initial_commit" != "$new_commit" ]; then
      if git -C "$repo_path" push "$remote_name" "$branch:$head_ref" >/dev/null 2>&1; then
        push_succeeded=1
        log "âœ… push: ${repo_full}#${number} â†’ $head_repo:$head_ref"
      else
        log "âš ï¸  push fehlgeschlagen fÃ¼r ${repo_full}#${number}"
      fi
    fi
  fi

  if [ "$remote_is_origin" -eq 0 ]; then
    git -C "$repo_path" remote remove "$remote_name" >/dev/null 2>&1 || true
  fi
  cleanup_pr_workspace "$repo_path" "$worktree" "$branch"

  if [ "$allow_push" -eq 1 ] && [ "$push_succeeded" -eq 1 ] && [ -n "$new_commit" ]; then
    write_state "${repo_full}#${number}:push" "$new_commit"
  fi

  return $status
}

while true; do
  mapfile -t PRS < <(fetch_open_prs || true)
  if [ ${#PRS[@]} -eq 0 ]; then
    sleep "$INTERVAL"
    continue
  fi

  for pr in "${PRS[@]}"; do
    repo_full="$(printf '%s' "$pr" | jq -r 'fromjson | .repo')"
    number="$(printf '%s' "$pr" | jq -r 'fromjson | .number')"
    sha="$(printf '%s' "$pr" | jq -r 'fromjson | .headSha')"
    head_ref="$(printf '%s' "$pr" | jq -r 'fromjson | (.headRef // "")')"
    head_repo="$(printf '%s' "$pr" | jq -r 'fromjson | (.headRepo // "")')"
    head_clone="$(printf '%s' "$pr" | jq -r 'fromjson | (.headClone // "")')"
    head_ssh="$(printf '%s' "$pr" | jq -r 'fromjson | (.headSsh // "")')"
    maint_can_modify="$(printf '%s' "$pr" | jq -r 'fromjson | (.maintainerCanModify // false)')"
    author="$(printf '%s' "$pr" | jq -r 'fromjson | (.author // "")')"
    [ "$repo_full" != "null" ] || continue
    [ "$number" != "null" ] || continue
    key="$repo_full#$number"
    last_sha="$(read_state "$key" || echo "")"
    if [ -n "$sha" ] && [ "$sha" = "$last_sha" ]; then
      continue
    fi

    log "ðŸŸ¦ review starte fÃ¼r ${repo_full}#${number}"
    if review_pr "$repo_full" "$number" "$sha" "$head_ref" "$head_repo" "$head_clone" "$head_ssh" "$maint_can_modify" "$author"; then
      [ -n "$sha" ] && write_state "$key" "$sha"
      log "âœ… review abgeschlossen fÃ¼r ${repo_full}#${number}"
    else
      log "âš ï¸  review fehlgeschlagen fÃ¼r ${repo_full}#${number}"
    fi
  done

  sleep "$INTERVAL"
done
