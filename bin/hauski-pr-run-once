#!/usr/bin/env bash

# --- SICHTER FRESH-BRANCH GUARD ---
ensure_fresh_branch() {
  local base_remote=origin base_branch=main
  git fetch "$base_remote" --prune --tags || true
  git switch --detach "$base_remote/$base_branch" >/dev/null 2>&1 || git checkout --detach "$base_remote/$base_branch"
  local ts br; ts="$(date +%Y%m%d-%H%M%S)"; br="sichter/autofix-$ts"
  git switch -C "$br" >/dev/null 2>&1 || git checkout -B "$br"
  echo "$br"
}

sichter_auto_pr() {
  local branch title body repo_name
  branch="$(git rev-parse --abbrev-ref HEAD)"
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  title="Sichter: auto PR (${repo_name})"
  body="Automatischer Vorschlag durch Sichter-Autopilot am $(date -Iseconds)"
  git push --set-upstream origin "$branch" --force-with-lease || true
  if gh pr view "$branch" --json number >/dev/null 2>&1; then
    gh pr comment "$branch" --body "ðŸ” Update $(date -Iseconds)" || true
  else
    gh pr create --base main --fill --title "$title" --body "$body" --label sichter --label automation || true
  fi
}
# --- END SICHTER FRESH-BRANCH GUARD ---
set -euo pipefail
LOG="$HOME/sichter/logs/pr-runner.log"
mkdir -p "$(dirname "$LOG")"
STATE="$HOME/sichter/review/pr-processed.json"
[ -f "$STATE" ] || echo '{}' >"$STATE"
ts() { date -Is; }
log() { echo "[runner] $*" | tee -a "$LOG"; }
jqget() { jq -r "$1" 2>/dev/null || echo ""; }

# ensure WORK is defined
WORK="${WORK:-$HOME}"

log "start $(ts)"

# PRs holen (nur echte JSON-Zeilen)
mapfile -t PRS < <(~/sichter/bin/hauski-pr-watch --once 2>>"$LOG" | grep -E '^\{')
[ "${#PRS[@]}" -eq 0 ] && {
	log "â„¹ï¸  keine PRs gefunden"
	log "done  $(ts)"
	exit 0
}

br=$(ensure_fresh_branch)
for J in "${PRS[@]}"; do
	repo="$(printf '%s' "$J" | jqget '.repo')"
	num="$(printf '%s' "$J" | jqget '.number')"
	[ -z "$repo" ] || [ -z "$num" ] && continue

	meta="$(gh pr view -R "$repo" "$num" --json headRefName,headRefOid,headRepository,maintainerCanModify \
		--jq '{headRefName, headRefOid, headRepo:(.headRepository.nameWithOwner//""), maintainerCanModify}')"
	sha="$(printf '%s' "$meta" | jqget '.headRefOid')"
	key="${repo}#${num}@${sha}"
	# schon verarbeitet?
	if jq -e --arg k "$key" '.[$k]' "$STATE" >/dev/null 2>&1; then
		continue
	fi

	log "â–¶ ${repo} #${num} ($(printf '%s' "$meta" | jqget '.headRefName'))"

	# Checkout PR (richtet Remote/Tracking automatisch)
	if ! gh pr checkout -R "$repo" "$num" -f >/dev/null 2>&1; then
		log "  âš ï¸ checkout fehlgeschlagen"
		continue
	fi
	touch "$WORK/sichter-enable"

	# Optionaler Auto-Fix-Hook
	if [ -x "$HOME/sichter/hooks/post-run" ]; then
		HAUSKI_AUTO_APPLY=1 HAUSKI_AUTO_COMMIT=1 HAUSKI_AUTO_PR=0 "$HOME/sichter/hooks/post-run" || true
	fi

	# Commit & Push, wenn Ã„nderungen
	git pull --rebase --autostash origin main || true
  git add -A || true
	# Nur committen, wenn etwas gestaged ist
	if ! git diff --cached --quiet; then
		git commit -m "hauski: autofix" || true
  sichter_auto_pr || true
		# Push: bevorzugt Upstream, sonst origin setzen
		upstream="$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null | cut -d/ -f1 || true)"
		branch="$(git rev-parse --abbrev-ref HEAD)"
		if [ -n "$upstream" ]; then
# SICHTER: disabled legacy push 			git push "$upstream" "$branch" || true
      true
		else
# SICHTER: disabled legacy push 			git push --set-upstream origin "$branch" || true
      true
		fi
	fi

	# State-Cache aktualisieren
	tmp="$(mktemp)"
	jq --arg k "$key" --arg t "$(ts)" '.[$k]=$t' "$STATE" >"$tmp" && mv "$tmp" "$STATE"
done

log "done  $(ts)"
