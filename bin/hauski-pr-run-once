#!/usr/bin/env bash

# --- SICHTER FRESH-BRANCH GUARD ---
ensure_fresh_branch() {
  local base_remote=origin base_branch=main
  git fetch "$base_remote" --prune --tags || true
  # immer auf exakt origin/main basieren (kein lokaler Drift)
  git switch --detach "$base_remote/$base_branch" >/dev/null 2>&1 || git checkout --detach "$base_remote/$base_branch"
  local ts br
  ts="$(date +%Y%m%d-%H%M%S)"
  br="sichter/autofix-$ts"
  git switch -C "$br" >/dev/null 2>&1 || git checkout -B "$br"
  echo "$br"
}

# PR-Helfer: erstellt/aktualisiert PR explizit gegen base=main
sichter_auto_pr() {
  local branch title body repo_name
  branch="$(git rev-parse --abbrev-ref HEAD)"
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  title="Sichter: auto PR (${repo_name})"
  body="Automatischer Vorschlag durch Sichter-Autopilot am $(date -Iseconds)"
  # Push with lease (keine Hard-Force), Branch anlegen falls nÃ¶tig
# SICHTER: disabled legacy push   git push --set-upstream origin "$branch" --force-with-lease || true
  if gh pr view "$branch" --json number >/dev/null 2>&1; then
    gh pr comment "$branch" --body "ðŸ” Update $(date -Iseconds)" || true
  else
    gh pr create --base main --fill --title "$title" --body "$body" --label sichter --label automation || true
  fi
}
# --- END SICHTER FRESH-BRANCH GUARD ---


# --- SICHTER FRESH-BRANCH GUARD ---
ensure_fresh_branch() {
  local base_remote=origin base_branch=main
  git fetch "$base_remote" --prune --tags || true
  # immer auf exakt origin/main basieren (kein lokaler Drift)
  git switch --detach "$base_remote/$base_branch" >/dev/null 2>&1 || git checkout --detach "$base_remote/$base_branch"
  local ts br
  ts="$(date +%Y%m%d-%H%M%S)"
  br="sichter/autofix-$ts"
  git switch -C "$br" >/dev/null 2>&1 || git checkout -B "$br"
  echo "$br"
}

# PR-Helfer: erstellt/aktualisiert PR explizit gegen base=main
sichter_auto_pr() {
  local branch title body repo_name
  branch="$(git rev-parse --abbrev-ref HEAD)"
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  title="Sichter: auto PR (${repo_name})"
  body="Automatischer Vorschlag durch Sichter-Autopilot am $(date -Iseconds)"
  # Push with lease (keine Hard-Force), Branch anlegen falls nÃ¶tig
# SICHTER: disabled legacy push   git push --set-upstream origin "$branch" --force-with-lease || true
  if gh pr view "$branch" --json number >/dev/null 2>&1; then
    gh pr comment "$branch" --body "ðŸ” Update $(date -Iseconds)" || true
  else
    gh pr create --base main --fill --title "$title" --body "$body" --label sichter --label automation || true
  fi
}
# --- END SICHTER FRESH-BRANCH GUARD ---


# === SICHTER-AUTO-PR BEGIN ===
sichter_auto_pr() {
  local repo_name pr_title pr_body branch
  branch="$(git rev-parse --abbrev-ref HEAD)"
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  pr_title="Sichter: auto PR ($repo_name)"
  pr_body="Automatischer Vorschlag durch Sichter-Autopilot am $(date -Iseconds)"
  if gh pr view "$branch" --json number >/dev/null 2>&1; then
    echo "â†» PR existiert bereits â†’ Kommentar"
    gh pr comment "$branch" --body "ðŸ” Update vom Sichter-Autopilot am $(date -Iseconds)" || true
  else
    echo "ðŸ“¤ Erstelle neuen PR: $pr_title"
    gh pr create --fill --title "$pr_title" --body "$pr_body" --label sichter --label automation --repo "heimgewebe/$repo_name" || true
  fi
}
# === SICHTER-AUTO-PR END ===

set -euo pipefail
LOG="$HOME/sichter/logs/pr-runner.log"; mkdir -p "$(dirname "$LOG")"
STATE="$HOME/sichter/review/pr-processed.json"; [ -f "$STATE" ] || echo '{}' > "$STATE"
ts(){ date -Is; }
log(){ echo "[runner] $*" | tee -a "$LOG"; }
jqget(){ jq -r "$1" 2>/dev/null || echo ""; }

log "start $(ts)"

# PRs holen (nur echte JSON-Zeilen)
mapfile -t PRS < <(~/sichter/bin/hauski-pr-watch --once 2>>"$LOG" | grep -E '^\{')
[ "${#PRS[@]}" -eq 0 ] && { log "â„¹ï¸  keine PRs gefunden"; log "done  $(ts)"; exit 0; }

br=$(ensure_fresh_branch)
br=$(ensure_fresh_branch)
for J in "${PRS[@]}"; do
  repo="$(printf '%s' "$J" | jqget '.repo')"
  num="$(printf  '%s' "$J" | jqget '.number')"
  [ -z "$repo" ] || [ -z "$num" ] && continue

  meta="$(gh pr view -R "$repo" "$num" --json headRefName,headRefOid,headRepository,maintainerCanModify \
          --jq '{headRefName, headRefOid, headRepo:(.headRepository.nameWithOwner//""), maintainerCanModify}')"
  sha="$(printf '%s' "$meta" | jqget '.headRefOid')"
  key="${repo}#${num}@${sha}"
  # schon verarbeitet?
  if jq -e --arg k "$key" '.[$k]' "$STATE" >/dev/null 2>&1; then
    continue
  fi

  log "â–¶ ${repo} #${num} ($(printf '%s' "$meta" | jqget '.headRefName'))"

  # Checkout PR (richtet Remote/Tracking automatisch)
  if ! gh pr checkout -R "$repo" "$num" -f >/dev/null 2>&1; then
    log "  âš ï¸ checkout fehlgeschlagen"; continue
  fi
  touch "$WORK/sichter-enable"

  # Optionaler Auto-Fix-Hook
  if [ -x "$HOME/sichter/hooks/post-run" ]; then
    HAUSKI_AUTO_APPLY=1 HAUSKI_AUTO_COMMIT=1 HAUSKI_AUTO_PR=0 "$HOME/sichter/hooks/post-run" || true
  fi

  # Commit & Push, wenn Ã„nderungen
  git pull --rebase --autostash origin main || true
  git add -A || true
  if ! git diff --cached; then
    git commit -m "hauski: autofix" || true
    # push auf Upstream, sonst set-upstream
    if !# SICHTER: disabled legacy push  git push; then
      upstream="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null | cut -d/ -f1 || true)"
      branch="$(git rev-parse --abbrev-ref HEAD)"
      [ -n "$upstream" ] &&# SICHTER: disabled legacy push  git push "$upstream" "$branch" || git push --set-upstream origin "$branch" || true
    sichter_auto_pr || true
    fi
  fi

  # State-Cache aktualisieren
  tmp="$(mktemp)"; jq --arg k "$key" --arg t "$(ts)" '.[$k]=$t' "$STATE" > "$tmp" && mv "$tmp" "$STATE"
done

log "done  $(ts)"

