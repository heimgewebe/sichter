#!/usr/bin/env bash
# --- SICHTER FRESH-BRANCH GUARD ---
ensure_fresh_branch() {
  local base_remote=origin base_branch=main
  git fetch "$base_remote" --prune --tags || true
  # immer exakt auf origin/main basieren (kein lokaler Drift)
  git switch --detach "$base_remote/$base_branch" >/dev/null 2>&1 || git checkout --detach "$base_remote/$base_branch"
  local ts br
  ts="$(date +%Y%m%d-%H%M%S)"
  br="sichter/autofix-$ts"
  git switch -C "$br" >/dev/null 2>&1 || git checkout -B "$br"
  echo "$br"
}

# PR-Helfer: erstellt/aktualisiert PR explizit gegen base=main
sichter_auto_pr() {
  local branch title body repo_name
  branch="$(git rev-parse --abbrev-ref HEAD)"
  repo_name="$(basename "$(git rev-parse --show-toplevel)")"
  title="Sichter: auto PR (${repo_name})"
  body="Automatischer Vorschlag durch Sichter-Autopilot am $(date -Iseconds)"

  # Push with lease (keine Hard-Force), Branch anlegen falls nÃ¶tig
  git push --set-upstream origin "${branch}" --force-with-lease || true
  if gh pr view "${branch}" --json number >/dev/null 2>&1; then
    gh pr comment "${branch}" --body "ðŸ” Update $(date -Iseconds)" || true
  else
    gh pr create --base main --fill --title "${title}" --body "${body}" --label sichter --label automation || true
  fi
}
# --- END SICHTER FRESH-BRANCH GUARD ---

set -euo pipefail

# Source the shared library
# shellcheck source=lib/common.sh
source "$(dirname "$(readlink -f "$0")")/../lib/common.sh"
parse_common_args "$@"

# Use relative paths from repo root
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || dirname "$(dirname "$(readlink -f "$0")")")"
LOG="$REPO_ROOT/logs/pr-runner.log"
mkdir -p "$(dirname "$LOG")"
STATE="$REPO_ROOT/review/pr-processed.json"
mkdir -p "$(dirname "$STATE")"
[ -f "$STATE" ] || echo '{}' >"$STATE"

ts() { date -Is; }
log() { echo "[runner] $*" | tee -a "$LOG"; }
jqget() { jq -r "$1" 2>/dev/null || echo ""; }

# ensure WORK is defined
WORK="${WORK:-$REPO_ROOT}"

log "start $(ts)"

# PRs holen (nur echte JSON-Zeilen)
mapfile -t PRS < <("$REPO_ROOT/bin/hauski-pr-watch" --once 2>>"$LOG" | grep -E '^\{')
if [ "${#PRS[@]}" -eq 0 ]; then
  log "â„¹ï¸  keine PRs gefunden"
  log "done  $(ts)"
  exit 0
fi

br="$(ensure_fresh_branch)"
for J in "${PRS[@]}"; do
  repo="$(printf '%s' "$J" | jqget '.repo')"
  num="$(printf '%s' "$J" | jqget '.number')"
  { [ -n "$repo" ] && [ -n "$num" ]; } || continue
  if ! validate_name_non_fatal "$repo"; then
    log "  âš ï¸ invalid repo name: $repo"
    continue
  fi
  if ! validate_name_non_fatal "$num"; then
    log "  âš ï¸ invalid pr number: $num"
    continue
  fi

  meta="$(gh pr view -R "${repo}" "${num}" \
    --json headRefName,headRefOid,headRepository,maintainerCanModify \
    --jq '{headRefName, headRefOid, headRepo:(.headRepository.nameWithOwner//""), maintainerCanModify}')"
  sha="$(printf '%s' "$meta" | jqget '.headRefOid')"
  key="${repo}#${num}@${sha}"

  # schon verarbeitet?
  if jq -e --arg k "${key}" '.[$k]' "${STATE}" >/dev/null 2>&1; then
    continue
  fi

  log "â–¶ ${repo} #${num} ($(printf '%s' "$meta" | jqget '.headRefName'))"

  # Checkout PR (richtet Remote/Tracking automatisch)
  if ! gh pr checkout -R "${repo}" "${num}" -f >/dev/null 2>&1; then
    log "  âš ï¸ checkout fehlgeschlagen"
    continue
  fi

  # Sichter-Autofix-Trigger (optional)
  touch "$WORK/sichter-enable"
  if [ -x "$REPO_ROOT/hooks/post-run" ]; then
    HAUSKI_AUTO_APPLY=1 HAUSKI_AUTO_COMMIT=1 HAUSKI_AUTO_PR=0 "$REPO_ROOT/hooks/post-run" || true
  fi

  # Commit & PR nur bei Ã„nderungen
  git pull --rebase --autostash origin main || true
  git add -A || true
  if ! git diff --cached --quiet; then
    git commit -m "hauski: autofix" || true
    sichter_auto_pr || true
  fi

  # State-Cache aktualisieren
  tmp="$(mktemp)"
  jq --arg k "$key" --arg t "$(ts)" '.[$k]=$t' "$STATE" >"$tmp" && mv "$tmp" "$STATE"
done

log "done  $(ts)"
