diff --git a/.github/workflows/ci-tools.yml b/.github/workflows/ci-tools.yml
index 7127a880..47da2064 100644
--- a/.github/workflows/ci-tools.yml
+++ b/.github/workflows/ci-tools.yml
@@ -127,11 +127,15 @@ jobs:
 
       - name: Cache uv
         if: ${{ hashFiles('pyproject.toml') != '' }}
-        uses: actions/cache@v4.0.2
+        uses: actions/cache@v4
         with:
           path: |
             ~/.cache/uv
             ~/.local/share/uv
+            ~/Library/Caches/uv
+            ~/Library/Application Support/uv
+            ~\AppData\Local\uv\Cache
+            ~\AppData\Roaming\uv
           key: ${{ runner.os }}-uv-${{ hashFiles('pyproject.toml', 'uv.lock', 'mkdocs.yml') }}
           restore-keys: |
             ${{ runner.os }}-uv-${{ hashFiles('pyproject.toml', 'uv.lock') }}-
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index a7e941ac..384b6532 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -322,19 +322,8 @@ jobs:
           # Fall back to "stable" if the workflow-level environment variable is empty.
           toolchain: ${{ env.RUST_TOOLCHAIN || 'stable' }}
       - uses: Swatinem/rust-cache@29f7d9a5c8d5a5ca45c8c7c3aa4642f3f7e87b94
-      - name: Build hauski-cli
-        run: cargo build -p hauski-cli
-      - name: Health smoke
-        run: |
-          set -euo pipefail
-          cargo run -p hauski-cli -- serve &
-          pid=$!
-          trap 'kill "$pid" 2>/dev/null || true' EXIT
-          sleep 1
-          curl -sf http://127.0.0.1:8080/health
-          kill "$pid"
-          wait "$pid" || true
-          trap - EXIT
+      - name: Health & chat smoke (mock ollama)
+        run: bash scripts/ci-smoke-chat.sh
   security:
     name: Rust — deny & audit
     needs: changes
diff --git a/.github/workflows/coverage.yml b/.github/workflows/coverage.yml
index b9cbcbb3..0aafbe0e 100644
--- a/.github/workflows/coverage.yml
+++ b/.github/workflows/coverage.yml
@@ -1,9 +1,8 @@
 name: coverage
 permissions:
   contents: read
-  actions: write
+  actions: write # required for rust-cache and upload-artifact
 
-# actions:write is required for rust-cache and upload-artifact to work
 on:
   pull_request:
     types: [opened, synchronize, reopened, ready_for_review]
@@ -25,41 +24,84 @@ jobs:
     runs-on: ubuntu-latest
     if: github.event_name != 'pull_request' || github.event.pull_request.draft == false
     timeout-minutes: 25
+
     steps:
       - name: Checkout repository
-        # Pin to fixed v4.2.2 release to keep builds deterministic
+        # Pin to fixed release for deterministic builds
         uses: actions/checkout@v4.2.2
-      - uses: dtolnay/rust-toolchain@stable
+
+      # Stable bleibt Default-Toolchain für Build-Schritte außerhalb Coverage
+      - name: Set up Rust toolchain
+        uses: dtolnay/rust-toolchain@stable
         with:
-          # Explicit input required by dtolnay/rust-toolchain to avoid setup failures.
           toolchain: stable
-          components: llvm-tools-preview
+
       - name: Ensure vendor snapshot
         run: bash scripts/ensure-vendor.sh
+
       - name: Check vendor snapshot
         run: bash scripts/check-vendor.sh
+
       - name: Cache cargo + target
-        uses: Swatinem/rust-cache@29f7d9a5c8d5a5ca45c8c7c3aa4642f3f7e87b94
+        # Pin to a specific release for reproducibility
+        uses: Swatinem/rust-cache@v2.7.7
         with:
           cache-on-failure: true
           shared-key: ${{ runner.os }}-cov-${{ hashFiles('**/Cargo.lock') }}
+
+      # Coverage läuft komplett mit nightly + llvm-tools, um Versionsmischung zu vermeiden
+      - name: Install nightly with llvm-tools
+        run: |
+          rustup set profile minimal
+          rustup toolchain install nightly --no-self-update --component llvm-tools-preview
+          rustup component list --toolchain nightly | grep llvm-tools
+
       - name: Install cargo-llvm-cov
         run: cargo install cargo-llvm-cov --locked --version 0.6.9
+
+      - name: Clean coverage profiles
+        run: cargo +nightly llvm-cov clean --workspace
+
       - name: Run coverage (focused)
         env:
-          # sufficient for llvm-cov; slightly faster than debuginfo=2
+          # slightly faster than debuginfo=2; sufficient for llvm-cov
           RUSTFLAGS: "-C debuginfo=1"
+          CARGO_INCREMENTAL: "0"
+          RUST_BACKTRACE: "1"
+          CARGO_TERM_COLOR: "always"
         run: |
           # measure only the runtime-relevant crates
           PKGS="--package hauski-core --package hauski-indexd"
-          cargo llvm-cov $PKGS --lcov --output-path lcov.info
+          echo "PKGS=$PKGS"
+          # 1) Erzeuge HTML-Report (inkl. Testlauf)
+          cargo +nightly llvm-cov $PKGS \
+            --all-features \
+            --doctests \
+            --fail-under-lines 65 \
+            --html
+          echo "HTML report: target/llvm-cov/html/index.html"
+
+          # 2) Erzeuge LCOV-Report aus den bereits gesammelten Profilen
+          cargo +nightly llvm-cov report \
+            --lcov --output-path lcov.info
+
+      - name: Upload HTML coverage
+        if: always()
+        uses: actions/upload-artifact@v4
+        with:
+          name: coverage-html
+          path: target/llvm-cov/html
+          retention-days: 7
+
       - name: Upload lcov
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: lcov.info
           path: lcov.info
-      # Coveralls optional – ein-/auskommentieren je nach Bedarf:
+          retention-days: 7
+
+      # Coveralls (optional)
       # - uses: coverallsapp/github-action@v2
       #   with:
       #     github-token: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.github/workflows/wgx-guard.yml b/.github/workflows/wgx-guard.yml
index 289f99a1..234e282a 100644
--- a/.github/workflows/wgx-guard.yml
+++ b/.github/workflows/wgx-guard.yml
@@ -38,9 +38,16 @@ jobs:
           cache: 'pip'
           cache-dependency-path: pyproject.toml
 
+      - name: Cache pip downloads
+        uses: actions/cache@v4
+        with:
+          path: ~/.cache/pip
+          key: pip-${{ runner.os }}-${{ hashFiles('pyproject.toml') }}
+          restore-keys: |
+            pip-${{ runner.os }}-
+
       - name: Install PyYAML
         run: |
-          pip install --disable-pip-version-check --upgrade pip
           pip install --disable-pip-version-check pyyaml==6.0.2
 
       - name: Run schema-lite check
@@ -65,24 +72,133 @@ jobs:
           print("schema-lite ok")
           PY
 
+      - name: (Optional) Cache uv & venv
+        if: ${{ hashFiles('pyproject.toml') != '' }}
+        uses: actions/cache@v4
+        with:
+          path: |
+            ~/.cache/uv
+            .venv
+          key: uv-${{ runner.os }}-${{ hashFiles('pyproject.toml', 'uv.lock') }}
+          restore-keys: |
+            uv-${{ runner.os }}-${{ hashFiles('pyproject.toml') }}-
+            uv-${{ runner.os }}-
+
       - name: (Optional) UV bootstrap (pyproject present)
         if: ${{ hashFiles('pyproject.toml') != '' }}
         run: |
           set -euo pipefail
-          # Installer erwartet exakte Release-Tags; installiere ohne Wildcard
-          curl -LsSf https://astral.sh/uv/install.sh | sh
+          python -m pip install --user --disable-pip-version-check 'uv>=0.8,<0.9'
           echo "$HOME/.local/bin" >> $GITHUB_PATH
-          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
-          # Für diesen Step PATH sofort setzen und gezielt auf 0.7.x bringen
-          export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$PATH"
-          uv self update 0.7.*
+          export PATH="$HOME/.local/bin:$PATH"
+          if ! command -v uv >/dev/null 2>&1; then
+            echo "::error::uv not found after pip install"
+            exit 1
+          fi
           ver="$(uv --version || true)"
           echo "uv version: $ver"
-          case "$ver" in
-            "uv 0.7."*) : ;;  # ok
-            *) echo "::error::uv 0.7.x erwartet, gefunden: $ver"; exit 1 ;;
-          esac
-          uv sync --frozen
+          if [[ "$ver" =~ ^uv\ ([0-9]+)\.([0-9]+)\. ]]; then
+            major="${BASH_REMATCH[1]}"
+            minor="${BASH_REMATCH[2]}"
+            if ! { [ "$major" -gt 0 ] || { [ "$major" -eq 0 ] && [ "$minor" -ge 8 ]; }; }; then
+              echo "::error::uv 0.8.x oder höher erwartet, gefunden: $ver"
+              echo "::notice::Bitte leere ggf. deinen Actions-Cache, falls eine alte uv-Version wiederhergestellt wurde."
+              exit 1
+            fi
+          else
+            echo "::error::uv version konnte nicht geparst werden: $ver"
+            exit 1
+          fi
+
+          if [ -f .wgx/profile.yml ] && [ -f pyproject.toml ]; then
+            WGX_PY="$(python - <<'PY'
+try:
+    import yaml  # type: ignore
+except Exception:
+    yaml = None
+
+def manual_parse(text: str) -> str:
+    fallback = "3.12"
+    lines = text.splitlines()
+    tooling = False
+    python = False
+    tooling_indent = None
+    python_indent = None
+    for line in lines:
+        raw = line.rstrip("\n")
+        stripped = raw.lstrip()
+        if not stripped or stripped.startswith('#'):
+            continue
+        indent = len(raw) - len(stripped)
+        if indent == 0:
+            tooling = stripped.startswith('tooling:')
+            python = False
+            tooling_indent = indent if tooling else None
+            continue
+        if tooling and tooling_indent is not None:
+            if indent <= tooling_indent:
+                tooling = False
+                python = False
+            elif stripped.startswith('python:'):
+                python = True
+                python_indent = indent
+                continue
+        if python and python_indent is not None:
+            if indent <= python_indent:
+                python = False
+            elif stripped.startswith('version:'):
+                value = stripped.split(':', 1)[1].strip().strip("'\"")
+                return value or fallback
+    return fallback
+
+try:
+    with open('.wgx/profile.yml', 'r', encoding='utf-8') as f:
+        content = f.read()
+except FileNotFoundError:
+    content = ''
+
+version = "3.12"
+if yaml:
+    try:
+        data = yaml.safe_load(content) or {}
+        version = str(data.get('tooling', {}).get('python', {}).get('version', '3.12'))
+    except Exception:
+        version = manual_parse(content)
+else:
+    version = manual_parse(content)
+
+version = '.'.join(version.split('.')[:2]) or '3.12'
+print(version)
+PY
+)"
+          else
+            WGX_PY="3.12"
+          fi
+
+          echo "WGX_PY=${WGX_PY}" >> "$GITHUB_ENV"
+
+          if [ -n "${WGX_PY:-}" ] && [ -f pyproject.toml ]; then
+            echo "Desired Python: ${WGX_PY}"
+            if ! uv python list --format json | grep -q "\"version\": \"${WGX_PY}"; then
+              echo "Installing managed Python ${WGX_PY} via uv…"
+              uv python install "${WGX_PY}"
+            else
+              echo "Managed Python ${WGX_PY} already present."
+            fi
+          fi
+
+          export UV_NO_SYNC_DOWNLOADS=1
+
+          if [ -f uv.lock ]; then
+            echo "using existing uv.lock → sync --frozen"
+            uv sync --frozen --python-preference=only-managed
+          else
+            echo "no uv.lock → creating lock + sync"
+            uv lock
+            uv sync --python-preference=only-managed
+          fi
+
+          echo "Final uv version: $(uv --version)"
 
       - name: Done
         run: echo "wgx-guard passed ✅"
diff --git a/.wgx/profile.yml b/.wgx/profile.yml
index d3602fd9..d5aa2dcc 100644
--- a/.wgx/profile.yml
+++ b/.wgx/profile.yml
@@ -2,6 +2,7 @@ version: 1
 
 # Ordered list of preferred execution environments for WGX tasks.
 env_priority:
+  - dev
   - default
   - devcontainer
   - devbox
@@ -11,7 +12,7 @@ env_priority:
 # Toolchain expectations for this repository.
 tooling:
   uv:
-    version: "0.7.x"
+    version: "0.8.x"
   python:
     version: "3.12"
     uv: true
diff --git a/Cargo.lock b/Cargo.lock
index e2b7fbc0..22139cda 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,6 +2,12 @@
 # It is not intended for manual editing.
 version = 4
 
+[[package]]
+name = "adler2"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"
+
 [[package]]
 name = "aho-corasick"
 version = "1.1.3"
@@ -74,6 +80,19 @@ dependencies = [
 name = "anyhow"
 version = "1.0.100"
 
+[[package]]
+name = "async-compression"
+version = "0.4.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a89bce6054c720275ac2432fbba080a66a2106a44a1b804553930ca6909f4e0"
+dependencies = [
+ "compression-codecs",
+ "compression-core",
+ "futures-core",
+ "pin-project-lite",
+ "tokio",
+]
+
 [[package]]
 name = "atomic-waker"
 version = "1.1.2"
@@ -178,6 +197,12 @@ version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"
 
+[[package]]
+name = "cfg_aliases"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"
+
 [[package]]
 name = "chrono"
 version = "0.4.42"
@@ -188,7 +213,7 @@ dependencies = [
  "js-sys",
  "num-traits",
  "wasm-bindgen",
- "windows-link 0.2.1",
+ "windows-link",
 ]
 
 [[package]]
@@ -238,21 +263,37 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"
 
 [[package]]
-name = "core-foundation"
-version = "0.9.4"
+name = "compression-codecs"
+version = "0.4.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
+checksum = "ef8a506ec4b81c460798f572caead636d57d3d7e940f998160f52bd254bf2d23"
 dependencies = [
- "core-foundation-sys",
- "libc",
+ "compression-core",
+ "flate2",
+ "memchr",
 ]
 
+[[package]]
+name = "compression-core"
+version = "0.4.29"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e47641d3deaf41fb1538ac1f54735925e275eaf3bf4d55c81b137fba797e5cbb"
+
 [[package]]
 name = "core-foundation-sys"
 version = "0.8.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
 
+[[package]]
+name = "crc32fast"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
+dependencies = [
+ "cfg-if",
+]
+
 [[package]]
 name = "crossbeam-channel"
 version = "0.5.15"
@@ -315,15 +356,6 @@ version = "1.0.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d6add3b8cff394282be81f3fc1a0605db594ed69890078ca6e2cab1c408bcf04"
 
-[[package]]
-name = "encoding_rs"
-version = "0.8.35"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
-dependencies = [
- "cfg-if",
-]
-
 [[package]]
 name = "equivalent"
 version = "1.0.2"
@@ -364,6 +396,16 @@ version = "0.1.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "52051878f80a721bb68ebfbc930e07b65ba72f2da88968ea5c06fd6ca3d3a127"
 
+[[package]]
+name = "flate2"
+version = "1.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfe33edd8e85a12a67454e37f8c75e730830d83e313556ab9ebf9ee7fbeb3bfb"
+dependencies = [
+ "crc32fast",
+ "miniz_oxide",
+]
+
 [[package]]
 name = "fnv"
 version = "1.0.7"
@@ -376,21 +418,6 @@ version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"
 
-[[package]]
-name = "foreign-types"
-version = "0.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
-dependencies = [
- "foreign-types-shared",
-]
-
-[[package]]
-name = "foreign-types-shared"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"
-
 [[package]]
 name = "form_urlencoded"
 version = "1.2.2"
@@ -484,8 +511,10 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
 dependencies = [
  "cfg-if",
+ "js-sys",
  "libc",
  "wasi",
+ "wasm-bindgen",
 ]
 
 [[package]]
@@ -495,28 +524,11 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
 dependencies = [
  "cfg-if",
+ "js-sys",
  "libc",
  "r-efi",
  "wasip2",
-]
-
-[[package]]
-name = "h2"
-version = "0.4.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f3c0b69cfcb4e1b9f1bf2f53f95f766e4661169728ec61cd3fe5a0166f2d1386"
-dependencies = [
- "atomic-waker",
- "bytes",
- "fnv",
- "futures-core",
- "futures-sink",
- "http",
- "indexmap",
- "slab",
- "tokio",
- "tokio-util",
- "tracing",
+ "wasm-bindgen",
 ]
 
 [[package]]
@@ -708,7 +720,6 @@ dependencies = [
  "bytes",
  "futures-channel",
  "futures-core",
- "h2",
  "http",
  "http-body",
  "httparse",
@@ -735,22 +746,7 @@ dependencies = [
  "tokio",
  "tokio-rustls",
  "tower-service",
-]
-
-[[package]]
-name = "hyper-tls"
-version = "0.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
-dependencies = [
- "bytes",
- "http-body-util",
- "hyper",
- "hyper-util",
- "native-tls",
- "tokio",
- "tokio-native-tls",
- "tower-service",
+ "webpki-roots",
 ]
 
 [[package]]
@@ -772,11 +768,9 @@ dependencies = [
  "percent-encoding",
  "pin-project-lite",
  "socket2",
- "system-configuration",
  "tokio",
  "tower-service",
  "tracing",
- "windows-registry",
 ]
 
 [[package]]
@@ -1020,6 +1014,12 @@ version = "0.4.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34080505efa8e45a4b816c349525ebe327ceaa8559756f0356cba97ef3bf7432"
 
+[[package]]
+name = "lru-slab"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"
+
 [[package]]
 name = "matchers"
 version = "0.2.0"
@@ -1048,31 +1048,24 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
 
 [[package]]
-name = "mio"
-version = "1.1.0"
+name = "miniz_oxide"
+version = "0.8.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "69d83b0086dc8ecf3ce9ae2874b2d1290252e2a30720bea58a5c6639b0092873"
+checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
 dependencies = [
- "libc",
- "wasi",
- "windows-sys 0.61.2",
+ "adler2",
+ "simd-adler32",
 ]
 
 [[package]]
-name = "native-tls"
-version = "0.2.14"
+name = "mio"
+version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "87de3442987e9dbec73158d5c715e7ad9072fda936bb03d19d7fa10e00520f0e"
+checksum = "69d83b0086dc8ecf3ce9ae2874b2d1290252e2a30720bea58a5c6639b0092873"
 dependencies = [
  "libc",
- "log",
- "openssl",
- "openssl-probe",
- "openssl-sys",
- "schannel",
- "security-framework",
- "security-framework-sys",
- "tempfile",
+ "wasi",
+ "windows-sys 0.61.2",
 ]
 
 [[package]]
@@ -1111,50 +1104,6 @@ version = "1.70.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"
 
-[[package]]
-name = "openssl"
-version = "0.10.74"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "24ad14dd45412269e1a30f52ad8f0664f0f4f4a89ee8fe28c3b3527021ebb654"
-dependencies = [
- "bitflags",
- "cfg-if",
- "foreign-types",
- "libc",
- "once_cell",
- "openssl-macros",
- "openssl-sys",
-]
-
-[[package]]
-name = "openssl-macros"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "openssl-probe"
-version = "0.1.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"
-
-[[package]]
-name = "openssl-sys"
-version = "0.9.110"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0a9f0075ba3c21b09f8e8b2026584b1d18d49388648f2fbbf3c97ea8deced8e2"
-dependencies = [
- "cc",
- "libc",
- "pkg-config",
- "vcpkg",
-]
-
 [[package]]
 name = "option-ext"
 version = "0.2.0"
@@ -1181,7 +1130,7 @@ dependencies = [
  "libc",
  "redox_syscall",
  "smallvec",
- "windows-link 0.2.1",
+ "windows-link",
 ]
 
 [[package]]
@@ -1240,6 +1189,15 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
 
+[[package]]
+name = "ppv-lite86"
+version = "0.2.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
+dependencies = [
+ "zerocopy",
+]
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.103"
@@ -1272,6 +1230,61 @@ dependencies = [
  "syn",
 ]
 
+[[package]]
+name = "quinn"
+version = "0.11.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9e20a958963c291dc322d98411f541009df2ced7b5a4f2bd52337638cfccf20"
+dependencies = [
+ "bytes",
+ "cfg_aliases",
+ "pin-project-lite",
+ "quinn-proto",
+ "quinn-udp",
+ "rustc-hash",
+ "rustls",
+ "socket2",
+ "thiserror 2.0.17",
+ "tokio",
+ "tracing",
+ "web-time",
+]
+
+[[package]]
+name = "quinn-proto"
+version = "0.11.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1906b49b0c3bc04b5fe5d86a77925ae6524a19b816ae38ce1e426255f1d8a31"
+dependencies = [
+ "bytes",
+ "getrandom 0.3.4",
+ "lru-slab",
+ "rand",
+ "ring",
+ "rustc-hash",
+ "rustls",
+ "rustls-pki-types",
+ "slab",
+ "thiserror 2.0.17",
+ "tinyvec",
+ "tracing",
+ "web-time",
+]
+
+[[package]]
+name = "quinn-udp"
+version = "0.5.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "addec6a0dcad8a8d96a771f815f0eaf55f9d1805756410b39f5fa81332574cbd"
+dependencies = [
+ "cfg_aliases",
+ "libc",
+ "once_cell",
+ "socket2",
+ "tracing",
+ "windows-sys 0.52.0",
+]
+
 [[package]]
 name = "quote"
 version = "1.0.41"
@@ -1287,6 +1300,35 @@ version = "5.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"
 
+[[package]]
+name = "rand"
+version = "0.9.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
+dependencies = [
+ "rand_chacha",
+ "rand_core",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
+dependencies = [
+ "ppv-lite86",
+ "rand_core",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
+dependencies = [
+ "getrandom 0.3.4",
+]
+
 [[package]]
 name = "redox_syscall"
 version = "0.5.18"
@@ -1342,31 +1384,31 @@ version = "0.12.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9d0946410b9f7b082a427e4ef5c8ff541a88b357bc6c637c40db3a68ac70a36f"
 dependencies = [
+ "async-compression",
  "base64",
  "bytes",
- "encoding_rs",
  "futures-core",
- "h2",
+ "futures-util",
  "http",
  "http-body",
  "http-body-util",
  "hyper",
  "hyper-rustls",
- "hyper-tls",
  "hyper-util",
  "js-sys",
  "log",
- "mime",
- "native-tls",
  "percent-encoding",
  "pin-project-lite",
+ "quinn",
+ "rustls",
  "rustls-pki-types",
  "serde",
  "serde_json",
  "serde_urlencoded",
  "sync_wrapper",
  "tokio",
- "tokio-native-tls",
+ "tokio-rustls",
+ "tokio-util",
  "tower",
  "tower-http",
  "tower-service",
@@ -1374,6 +1416,7 @@ dependencies = [
  "wasm-bindgen",
  "wasm-bindgen-futures",
  "web-sys",
+ "webpki-roots",
 ]
 
 [[package]]
@@ -1404,6 +1447,12 @@ dependencies = [
  "smallvec",
 ]
 
+[[package]]
+name = "rustc-hash"
+version = "2.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"
+
 [[package]]
 name = "rustix"
 version = "1.1.2"
@@ -1424,6 +1473,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6a9586e9ee2b4f8fab52a0048ca7334d7024eef48e2cb9407e3497bb7cab7fa7"
 dependencies = [
  "once_cell",
+ "ring",
  "rustls-pki-types",
  "rustls-webpki",
  "subtle",
@@ -1436,6 +1486,7 @@ version = "1.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
 dependencies = [
+ "web-time",
  "zeroize",
 ]
 
@@ -1480,15 +1531,6 @@ dependencies = [
  "sdd",
 ]
 
-[[package]]
-name = "schannel"
-version = "0.1.28"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "891d81b926048e76efe18581bf793546b4c0eaf8448d72be8de2bbee5fd166e1"
-dependencies = [
- "windows-sys 0.61.2",
-]
-
 [[package]]
 name = "scopeguard"
 version = "1.2.0"
@@ -1501,29 +1543,6 @@ version = "3.0.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "490dcfcbfef26be6800d11870ff2df8774fa6e86d047e3e8c8a76b25655e41ca"
 
-[[package]]
-name = "security-framework"
-version = "2.11.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
-dependencies = [
- "bitflags",
- "core-foundation",
- "core-foundation-sys",
- "libc",
- "security-framework-sys",
-]
-
-[[package]]
-name = "security-framework-sys"
-version = "2.15.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cc1f0cbffaac4852523ce30d8bd3c5cdc873501d96ff467ca09b6767bb8cd5c0"
-dependencies = [
- "core-foundation-sys",
- "libc",
-]
-
 [[package]]
 name = "serde"
 version = "1.0.228"
@@ -1659,6 +1678,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "simd-adler32"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"
+
 [[package]]
 name = "slab"
 version = "0.4.11"
@@ -1730,27 +1755,6 @@ dependencies = [
  "syn",
 ]
 
-[[package]]
-name = "system-configuration"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3c879d448e9d986b661742763247d3693ed13609438cf3d006f51f5368a5ba6b"
-dependencies = [
- "bitflags",
- "core-foundation",
- "system-configuration-sys",
-]
-
-[[package]]
-name = "system-configuration-sys"
-version = "0.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e1d1b10ced5ca923a1fcb8d03e96b8d3268065d724548c0211415ff6ac6bac4"
-dependencies = [
- "core-foundation-sys",
- "libc",
-]
-
 [[package]]
 name = "tempfile"
 version = "3.23.0"
@@ -1854,6 +1858,21 @@ dependencies = [
  "zerovec",
 ]
 
+[[package]]
+name = "tinyvec"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
+dependencies = [
+ "tinyvec_macros",
+]
+
+[[package]]
+name = "tinyvec_macros"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
+
 [[package]]
 name = "tokio"
 version = "1.48.0"
@@ -1881,16 +1900,6 @@ dependencies = [
  "syn",
 ]
 
-[[package]]
-name = "tokio-native-tls"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
-dependencies = [
- "native-tls",
- "tokio",
-]
-
 [[package]]
 name = "tokio-rustls"
 version = "0.26.4"
@@ -2239,6 +2248,25 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "web-time"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32b130c0d2d49f8b6889abc456e795e82525204f27c42cf767cf0d7734e089b8"
+dependencies = [
+ "rustls-pki-types",
+]
+
 [[package]]
 name = "winapi-util"
 version = "0.1.11"
@@ -2256,9 +2284,9 @@ checksum = "b8e83a14d34d0623b51dce9581199302a221863196a1dde71a7663a4c2be9deb"
 dependencies = [
  "windows-implement",
  "windows-interface",
- "windows-link 0.2.1",
- "windows-result 0.4.1",
- "windows-strings 0.5.1",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
 ]
 
 [[package]]
@@ -2283,54 +2311,19 @@ dependencies = [
  "syn",
 ]
 
-[[package]]
-name = "windows-link"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"
-
 [[package]]
 name = "windows-link"
 version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"
 
-[[package]]
-name = "windows-registry"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b8a9ed28765efc97bbc954883f4e6796c33a06546ebafacbabee9696967499e"
-dependencies = [
- "windows-link 0.1.3",
- "windows-result 0.3.4",
- "windows-strings 0.4.2",
-]
-
-[[package]]
-name = "windows-result"
-version = "0.3.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
-dependencies = [
- "windows-link 0.1.3",
-]
-
 [[package]]
 name = "windows-result"
 version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7781fa89eaf60850ac3d2da7af8e5242a5ea78d1a11c49bf2910bb5a73853eb5"
 dependencies = [
- "windows-link 0.2.1",
-]
-
-[[package]]
-name = "windows-strings"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
-dependencies = [
- "windows-link 0.1.3",
+ "windows-link",
 ]
 
 [[package]]
@@ -2339,7 +2332,7 @@ version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7837d08f69c77cf6b07689544538e017c1bfcf57e34b4c0ff58e6c2cd3b37091"
 dependencies = [
- "windows-link 0.2.1",
+ "windows-link",
 ]
 
 [[package]]
@@ -2366,7 +2359,7 @@ version = "0.61.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
 dependencies = [
- "windows-link 0.2.1",
+ "windows-link",
 ]
 
 [[package]]
@@ -2391,7 +2384,7 @@ version = "0.53.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
 dependencies = [
- "windows-link 0.2.1",
+ "windows-link",
  "windows_aarch64_gnullvm 0.53.1",
  "windows_aarch64_msvc 0.53.1",
  "windows_i686_gnu 0.53.1",
@@ -2534,6 +2527,26 @@ dependencies = [
  "synstructure",
 ]
 
+[[package]]
+name = "zerocopy"
+version = "0.8.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0894878a5fa3edfd6da3f88c4805f4c8558e2b996227a3d864f47fe11e38282c"
+dependencies = [
+ "zerocopy-derive",
+]
+
+[[package]]
+name = "zerocopy-derive"
+version = "0.8.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "88d2b8d9c68ad2b9e4340d7832716a4d21a22a1154777ad56ea55c51a9cf3831"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
 [[package]]
 name = "zerofrom"
 version = "0.1.6"
diff --git a/Cargo.toml b/Cargo.toml
index 4757e399..1b9bcbfc 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -36,7 +36,7 @@ http-body-util = "0.1"
 serial_test = "3"
 tempfile = "3"
 # sqlx bewusst nicht vorgezogen, bis erste DB-Crate existiert
-reqwest = { version = "0.12", features = ["json"] }
+reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls-webpki-roots", "gzip"] }
 url = "2"
 rusqlite = { version = "0.37.0", features = ["bundled"] }
 chrono = { version = "0.4", features = ["clock"] }
diff --git a/crates/core/Cargo.toml b/crates/core/Cargo.toml
index 93c58664..0e569413 100644
--- a/crates/core/Cargo.toml
+++ b/crates/core/Cargo.toml
@@ -28,5 +28,5 @@ utoipa.workspace = true
 [dev-dependencies]
 tower = { workspace = true, features = ["util"] }
 http-body-util.workspace = true
-serial_test.workspace = true
+serial_test = "3"
 tempfile.workspace = true
diff --git a/crates/core/src/ask.rs b/crates/core/src/ask.rs
index 3d1a9ee8..61a06dce 100644
--- a/crates/core/src/ask.rs
+++ b/crates/core/src/ask.rs
@@ -7,6 +7,7 @@ use axum::{
 };
 use hauski_indexd::SearchRequest;
 use serde::{Deserialize, Serialize};
+use serde_json::json;
 use utoipa::{IntoParams, ToSchema};
 
 use crate::AppState;
@@ -14,7 +15,17 @@ use crate::AppState;
 /// Maximum number of matches returned by the `/ask` endpoint.
 const MAX_K: usize = 100;
 
-#[derive(Serialize, Deserialize, Debug, ToSchema)]
+#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
+#[schema(
+    title = "AskHit",
+    example = json!({
+        "doc_id": "doc-42",
+        "namespace": "default",
+        "score": 0.87,
+        "snippet": "HausKI keeps your knowledge organized.",
+        "meta": {"source": "docs/intro.md"}
+    })
+)]
 pub struct AskHit {
     pub doc_id: String,
     pub namespace: String,
@@ -23,7 +34,24 @@ pub struct AskHit {
     pub meta: serde_json::Value,
 }
 
-#[derive(Serialize, Deserialize, Debug, ToSchema)]
+#[derive(Serialize, Deserialize, Debug, Clone, ToSchema)]
+#[schema(
+    title = "AskResponse",
+    example = json!({
+        "query": "What is HausKI?",
+        "k": 5,
+        "namespace": "default",
+        "hits": [
+            {
+                "doc_id": "doc-42",
+                "namespace": "default",
+                "score": 0.87,
+                "snippet": "HausKI keeps your knowledge organized.",
+                "meta": {"source": "docs/intro.md"}
+            }
+        ]
+    })
+)]
 pub struct AskResponse {
     pub query: String,
     pub k: usize,
@@ -31,7 +59,7 @@ pub struct AskResponse {
     pub hits: Vec<AskHit>,
 }
 
-#[derive(Deserialize, IntoParams, ToSchema)]
+#[derive(Deserialize, Clone, IntoParams, ToSchema)]
 #[into_params(parameter_in = Query)]
 pub struct AskParams {
     /// The query string for semantic search.
diff --git a/crates/core/src/chat.rs b/crates/core/src/chat.rs
index 6e934051..7b108511 100644
--- a/crates/core/src/chat.rs
+++ b/crates/core/src/chat.rs
@@ -2,11 +2,13 @@ use std::{env, time::Instant};
 
 use axum::{
     extract::State,
-    http::{Method, StatusCode},
+    http::{HeaderMap, HeaderValue, Method, StatusCode},
     response::IntoResponse,
     Json,
 };
 use serde::{Deserialize, Serialize};
+#[allow(unused_imports)]
+use serde_json::json;
 use tracing::{debug, warn};
 use utoipa::ToSchema;
 
@@ -28,11 +30,11 @@ impl ChatCfg {
         }
     }
 
-    pub fn from_env_and_flags(flag_upstream: Option<String>) -> Self {
+    pub fn from_env_and_flags(flag_upstream: Option<String>, flag_model: Option<String>) -> Self {
         let upstream_env =
             env_var("HAUSKI_CHAT_UPSTREAM_URL").or_else(|| env_var("CHAT_UPSTREAM_URL"));
         let upstream_url = upstream_env.or(flag_upstream);
-        let model = env_var("HAUSKI_CHAT_MODEL");
+        let model = env_var("HAUSKI_CHAT_MODEL").or(flag_model);
 
         Self::new(upstream_url, model)
     }
@@ -52,17 +54,35 @@ fn env_var(key: &str) -> Option<String> {
     }
 }
 
-const DEFAULT_MODEL: &str = "llama";
+/// Allowed roles for chat messages.
+#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
+#[serde(rename_all = "lowercase")]
+#[schema(title = "ChatRole", example = "user")]
+pub enum ChatRole {
+    System,
+    User,
+    Assistant,
+    #[serde(alias = "tool", alias = "function")]
+    Tool,
+}
+
+const MAX_MESSAGES: usize = 32;
+const MAX_CHARS_PER_MSG: usize = 16_000;
+const RETRY_AFTER_SECS: &str = "30";
 
-#[derive(Debug, Deserialize, Serialize, ToSchema)]
+#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
+#[serde(deny_unknown_fields)]
+#[schema(title = "ChatMessage", example = json!({"role":"user","content":"Hallo HausKI?"}))]
 pub struct ChatMessage {
     /// Role of the message author (e.g. user, system, assistant).
-    pub role: String,
+    pub role: ChatRole,
     /// Natural language content submitted by the author.
     pub content: String,
 }
 
-#[derive(Debug, Serialize, ToSchema)]
+#[derive(Debug, Clone, Serialize, ToSchema)]
+#[serde(deny_unknown_fields)]
+#[schema(title = "ChatResponse", example = json!({"content":"Hallo! Wie kann ich helfen?","model":"llama3.1-8b-q4"}))]
 pub struct ChatResponse {
     /// Assistant message content produced by the upstream model.
     pub content: String,
@@ -70,17 +90,23 @@ pub struct ChatResponse {
     pub model: String,
 }
 
-#[derive(Debug, Deserialize, ToSchema)]
+#[derive(Debug, Clone, Deserialize, ToSchema)]
+#[serde(deny_unknown_fields)]
+#[schema(title = "ChatRequest", example = json!({"messages":[{"role":"user","content":"Hallo HausKI?"}]}))]
 pub struct ChatRequest {
     /// Sequence of messages forming the current conversation turn.
     pub messages: Vec<ChatMessage>,
 }
 
-#[derive(Debug, Serialize, Deserialize, ToSchema)]
+#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
+#[serde(deny_unknown_fields)]
+#[schema(title = "ChatStubResponse", example = json!({
+    "status": "unavailable",
+    "message": "chat pipeline not wired yet, please configure HAUSKI_CHAT_UPSTREAM_URL"
+}))]
 pub struct ChatStubResponse {
-    /// Static status marker highlighting that the endpoint is not wired yet.
+    /// Stub information for unimplemented or failed chat routes.
     pub status: String,
-    /// Human readable explanation for clients.
     pub message: String,
 }
 
@@ -106,7 +132,10 @@ mod tests {
         std::env::set_var("HAUSKI_CHAT_UPSTREAM_URL", " https://example.invalid/chat ");
         std::env::set_var("HAUSKI_CHAT_MODEL", " llama-3.1 ");
 
-        let cfg = ChatCfg::from_env_and_flags(Some("https://flag.invalid".to_string()));
+        let cfg = ChatCfg::from_env_and_flags(
+            Some("https://flag.invalid".to_string()),
+            Some("flag-model".to_string()),
+        );
 
         assert_eq!(
             cfg.upstream_url.as_deref(),
@@ -123,10 +152,10 @@ mod tests {
         clear_env_vars();
         std::env::set_var("CHAT_UPSTREAM_URL", "http://legacy.invalid");
 
-        let cfg = ChatCfg::from_env_and_flags(None);
+        let cfg = ChatCfg::from_env_and_flags(None, Some("flag-model".to_string()));
 
         assert_eq!(cfg.upstream_url.as_deref(), Some("http://legacy.invalid"));
-        assert!(cfg.model.is_none());
+        assert_eq!(cfg.model.as_deref(), Some("flag-model"));
 
         clear_env_vars();
     }
@@ -137,15 +166,75 @@ mod tests {
         clear_env_vars();
         std::env::set_var("HAUSKI_CHAT_UPSTREAM_URL", "   ");
 
-        let cfg = ChatCfg::from_env_and_flags(Some("https://flag.invalid".to_string()));
+        let cfg = ChatCfg::from_env_and_flags(
+            Some("https://flag.invalid".to_string()),
+            Some("flag-model".to_string()),
+        );
 
         assert_eq!(cfg.upstream_url.as_deref(), Some("https://flag.invalid"));
+        assert_eq!(cfg.model.as_deref(), Some("flag-model"));
+
+        clear_env_vars();
+    }
+
+    #[test]
+    #[serial]
+    fn from_env_returns_none_when_flags_absent() {
+        clear_env_vars();
+
+        let cfg = ChatCfg::from_env_and_flags(None, None);
+
+        assert!(cfg.upstream_url.is_none());
         assert!(cfg.model.is_none());
 
         clear_env_vars();
     }
 }
 
+/// Lightweight input validation to protect upstreams and keep error reporting clear.
+fn validate_chat_request(req: &ChatRequest) -> Result<(), ChatStubResponse> {
+    if req.messages.is_empty() {
+        return Err(ChatStubResponse {
+            status: "bad_request".to_string(),
+            message: "messages must not be empty".to_string(),
+        });
+    }
+
+    if req.messages.len() > MAX_MESSAGES {
+        return Err(ChatStubResponse {
+            status: "too_many_messages".to_string(),
+            message: format!("messages limited to {MAX_MESSAGES}"),
+        });
+    }
+
+    if let Some((index, _)) = req
+        .messages
+        .iter()
+        .enumerate()
+        .find(|(_, message)| message.content.trim().is_empty())
+    {
+        return Err(ChatStubResponse {
+            status: "bad_request".to_string(),
+            message: format!("message {index} must not be empty"),
+        });
+    }
+
+    if let Some((index, _)) = req
+        .messages
+        .iter()
+        .enumerate()
+        .find(|(_, message)| message.content.chars().count() > MAX_CHARS_PER_MSG)
+    {
+        return Err(ChatStubResponse {
+            status: "message_too_long".to_string(),
+            message: format!("message {index} exceeds {MAX_CHARS_PER_MSG} chars"),
+        });
+    }
+
+    Ok(())
+}
+
+// Hinweis: Wir dokumentieren die `Retry-After`-Header für 503-Antworten.
 #[utoipa::path(
     post,
     path = "/v1/chat",
@@ -156,66 +245,96 @@ mod tests {
             description = "Successful chat response via configured upstream",
             body = ChatResponse
         ),
+        (
+            status = 400,
+            description = "Invalid chat request payload",
+            body = ChatStubResponse
+        ),
         (
             status = 502,
             description = "Configured chat upstream returned an error",
             body = ChatStubResponse
         ),
         (
-            status = 501,
-            description = "Chat endpoint not yet implemented",
-            body = ChatStubResponse
+            status = 503,
+            description = "Chat endpoint not currently available",
+            body = ChatStubResponse,
+            headers(
+                ("Retry-After" = String, description = "Client backoff in seconds")
+            )
         )
     ),
     tag = "core"
 )]
-pub async fn post_chat(
+pub async fn chat_handler(
     State(state): State<AppState>,
     Json(chat_request): Json<ChatRequest>,
 ) -> axum::response::Response {
-    let chat_cfg = state.chat_cfg();
+    let started = Instant::now();
+
+    if let Err(payload) = validate_chat_request(&chat_request) {
+        let status = StatusCode::BAD_REQUEST;
+        state.record_http_observation(Method::POST, "/v1/chat", status, started);
+        return (status, Json(payload)).into_response();
+    }
 
+    let chat_cfg = state.chat_cfg();
     if let Some(base_url) = chat_cfg.upstream_url.clone() {
-        let started = Instant::now();
-        let client = chat_cfg.client.clone();
-        let model = chat_cfg
-            .model
-            .clone()
-            .unwrap_or_else(|| DEFAULT_MODEL.to_string());
-
-        match call_ollama_chat(&client, &base_url, &model, &chat_request.messages).await {
-            Ok(content) => {
-                let status = StatusCode::OK;
-                state.record_http_observation(Method::POST, "/v1/chat", status, started);
-                debug!(
-                    base_url = %base_url,
-                    status = %status,
-                    model = %model,
-                    "chat upstream succeeded"
-                );
-                return (status, Json(ChatResponse { content, model })).into_response();
-            }
-            Err(err) => {
-                let status = StatusCode::BAD_GATEWAY;
-                state.record_http_observation(Method::POST, "/v1/chat", status, started);
-                debug!(base_url = %base_url, error = %err, "chat upstream failed");
-                let payload = ChatStubResponse {
-                    status: "upstream_error".to_string(),
-                    message: format!("chat upstream failed: {err}"),
-                };
-                return (status, Json(payload)).into_response();
+        if let Some(model) = chat_cfg.model.clone() {
+            let client = chat_cfg.client.clone();
+
+            match call_ollama_chat(&client, &base_url, &model, &chat_request.messages).await {
+                Ok(content) => {
+                    let status = StatusCode::OK;
+                    state.record_http_observation(Method::POST, "/v1/chat", status, started);
+                    debug!(
+                        base_url = %base_url,
+                        status = %status,
+                        model = %model,
+                        "chat upstream succeeded"
+                    );
+                    return (status, Json(ChatResponse { content, model })).into_response();
+                }
+                Err(err) => {
+                    let status = StatusCode::BAD_GATEWAY;
+                    state.record_http_observation(Method::POST, "/v1/chat", status, started);
+                    debug!(base_url = %base_url, error = %err, "chat upstream failed");
+                    let payload = ChatStubResponse {
+                        status: "upstream_error".to_string(),
+                        message: format!("chat upstream failed: {err}"),
+                    };
+                    return (status, Json(payload)).into_response();
+                }
             }
         }
+
+        warn!("chat request received but no chat model is configured");
+        let status = StatusCode::SERVICE_UNAVAILABLE;
+        let mut headers = HeaderMap::new();
+        headers.insert(
+            axum::http::header::RETRY_AFTER,
+            HeaderValue::from_static(RETRY_AFTER_SECS),
+        );
+        state.record_http_observation(Method::POST, "/v1/chat", status, started);
+        let payload = ChatStubResponse {
+            status: "unavailable".to_string(),
+            message: "missing HAUSKI_CHAT_MODEL".to_string(),
+        };
+        return (status, headers, Json(payload)).into_response();
     }
 
     warn!("chat request received but no chat upstream is configured");
-    let started = Instant::now();
-    let status = StatusCode::NOT_IMPLEMENTED;
+    let status = StatusCode::SERVICE_UNAVAILABLE;
+    let mut headers = HeaderMap::new();
+    headers.insert(
+        axum::http::header::RETRY_AFTER,
+        HeaderValue::from_static(RETRY_AFTER_SECS),
+    );
     state.record_http_observation(Method::POST, "/v1/chat", status, started);
     let payload = ChatStubResponse {
-        status: "not_implemented".to_string(),
+        status: "unavailable".to_string(),
         message: "chat pipeline not wired yet, please configure HAUSKI_CHAT_UPSTREAM_URL"
             .to_string(),
     };
-    (status, Json(payload)).into_response()
+    (status, headers, Json(payload)).into_response()
 }
diff --git a/crates/core/src/lib.rs b/crates/core/src/lib.rs
index bf6b15c2..8815d47e 100644
--- a/crates/core/src/lib.rs
+++ b/crates/core/src/lib.rs
@@ -47,7 +47,7 @@ type MetricsCallback = dyn Fn(Method, &'static str, StatusCode, Instant) + Send
 
 #[derive(OpenApi)]
 #[openapi(
-    paths(health, healthz, ready, ask::ask_handler, chat::post_chat),
+    paths(health, healthz, ready, ask::ask_handler, chat::chat_handler),
     components(
         schemas(
             ask::AskResponse,
@@ -112,14 +112,11 @@ impl AppState {
         models: ModelsFile,
         routing: RoutingPolicy,
         flags: FeatureFlags,
+        chat_cfg: Arc<chat::ChatCfg>,
         expose_config: bool,
     ) -> Self {
         let mut registry = Registry::default();
 
-        let chat_cfg = Arc::new(chat::ChatCfg::from_env_and_flags(
-            flags.chat_upstream_url.clone(),
-        ));
-
         let build_info = Family::<BuildInfoLabels, Gauge>::default();
         build_info
             .get_or_create(&BuildInfoLabels {
@@ -420,7 +417,11 @@ pub fn build_app_with_state(
     expose_config: bool,
     allowed_origin: HeaderValue,
 ) -> (Router, AppState) {
-    let state = AppState::new(limits, models, routing, flags, expose_config);
+    let chat_cfg = Arc::new(chat::ChatCfg::from_env_and_flags(
+        flags.chat_upstream_url.clone(),
+        flags.chat_model.clone(),
+    ));
+    let state = AppState::new(limits, models, routing, flags, chat_cfg, expose_config);
     let allowed_origin = Arc::new(allowed_origin);
 
     // --- Request guards ------------------------------------------------------
@@ -508,7 +509,7 @@ fn core_routes() -> Router<AppState> {
         .route("/ready", get(ready))
         .route("/metrics", get(metrics))
         .route("/ask", get(ask::ask_handler))
-        .route("/v1/chat", post(chat::post_chat))
+        .route("/v1/chat", post(chat::chat_handler))
 }
 
 fn docs_routes() -> Router<AppState> {
diff --git a/crates/core/tests/chat_unconfigured.rs b/crates/core/tests/chat_unconfigured.rs
new file mode 100644
index 00000000..e2d4ad41
--- /dev/null
+++ b/crates/core/tests/chat_unconfigured.rs
@@ -0,0 +1,66 @@
+use axum::{
+    body::Body,
+    http::{self, HeaderValue, Request, StatusCode},
+    Router,
+};
+use hauski_core::{build_app_with_state, FeatureFlags, Limits, ModelsFile, RoutingPolicy};
+use http_body_util::BodyExt;
+use serde_json::{json, Value};
+use tower::ServiceExt;
+
+fn default_app() -> Router {
+    for key in [
+        "HAUSKI_CHAT_UPSTREAM_URL",
+        "CHAT_UPSTREAM_URL",
+        "HAUSKI_CHAT_MODEL",
+    ] {
+        std::env::remove_var(key);
+    }
+
+    let limits = Limits::default();
+    let models = ModelsFile::default();
+    let routing = RoutingPolicy::default();
+    let flags = FeatureFlags::default();
+    let allowed_origin = HeaderValue::from_static("*");
+    let (app, _state) = build_app_with_state(limits, models, routing, flags, false, allowed_origin);
+    app
+}
+
+#[tokio::test]
+async fn chat_returns_503_when_unconfigured() {
+    let app = default_app();
+    let payload = json!({
+        "messages": [
+            {"role": "user", "content": "Ping?"}
+        ]
+    });
+
+    let response = app
+        .clone()
+        .oneshot(
+            Request::post("/v1/chat")
+                .header(http::header::CONTENT_TYPE, "application/json")
+                .body(Body::from(payload.to_string()))
+                .expect("failed to build request"),
+        )
+        .await
+        .expect("request failed");
+
+    assert_eq!(response.status(), StatusCode::SERVICE_UNAVAILABLE);
+    let retry_after = response
+        .headers()
+        .get(http::header::RETRY_AFTER)
+        .expect("missing Retry-After header")
+        .to_str()
+        .expect("Retry-After not valid utf8");
+    assert_eq!(retry_after, "30");
+
+    let body_bytes = response
+        .into_body()
+        .collect()
+        .await
+        .expect("body bytes")
+        .to_bytes();
+    let stub: Value = serde_json::from_slice(&body_bytes).expect("stub response");
+    assert_eq!(stub["status"], "unavailable");
+}
diff --git a/crates/core/tests/metrics_smoke.rs b/crates/core/tests/metrics_smoke.rs
index 4ff1df26..60a9669a 100644
--- a/crates/core/tests/metrics_smoke.rs
+++ b/crates/core/tests/metrics_smoke.rs
@@ -1,5 +1,5 @@
 //! Minimaler Smoke-Test für `/metrics`.
-//! 
+//!
 //! Dieser Test ist bewusst als `#[ignore]` markiert, damit reguläre CI-Läufe
 //! nicht scheitern, wenn kein Server läuft. Er kann gezielt aktiviert werden:
 //!
@@ -29,7 +29,11 @@ async fn metrics_endpoint_exposes_prometheus_text() {
         .await
         .expect("request to /metrics failed");
 
-    assert_eq!(resp.status(), StatusCode::OK, "unexpected status for /metrics");
+    assert_eq!(
+        resp.status(),
+        StatusCode::OK,
+        "unexpected status for /metrics"
+    );
 
     // Content-Type sollte Prometheus-Textformat sein
     let ctype = resp
@@ -53,4 +57,3 @@ async fn metrics_endpoint_exposes_prometheus_text() {
         &body.as_bytes().get(0..64)
     );
 }
-
diff --git a/deny.toml b/deny.toml
index 1cb1432a..6992f74c 100644
--- a/deny.toml
+++ b/deny.toml
@@ -1,14 +1,44 @@
 [graph]
-targets = [{ triple = "x86_64-unknown-linux-gnu" }]
+targets = [
+    { triple = "x86_64-unknown-linux-gnu" },
+    { triple = "aarch64-unknown-linux-gnu" },
+]
 
 [advisories]
 version = 2
+vulnerability = "deny"
+unmaintained = "warn"
+unsound = "deny"
 yanked = "warn"
+ignore = []
 
 [licenses]
 version = 2
-allow = ["MIT", "Apache-2.0", "BSD-3-Clause", "MPL-2.0", "Unicode-3.0", "Zlib"]
+allow = [
+    "MIT",
+    "Apache-2.0",
+    "BSD-3-Clause",
+    "BSD-2-Clause",
+    "BSD-3-Clause-Clear",
+    "MPL-2.0",
+    # Präziser Unicode-Identifier, den viele Crates nutzen:
+    "Unicode-DFS-2016",
+    # Für ältere Crates zusätzlich erlaubt:
+    "Unicode-3.0",
+    "Zlib",
+    "ISC",
+    "OpenSSL",
+    "CC0-1.0",
+]
 confidence-threshold = 0.9
+# Wie mit problematischen Klassen umgehen:
+unlicensed = "deny"
+unknown = "deny"
+copyleft = "deny" # auf "warn" setzen, wenn du temporäre Toleranz brauchst
+# Optional: lokale Eigenlizenz (für hausKI-Repos)
+# Optional: Private Crates im Monorepo vom Lizenz-Gate ausnehmen
+#   (nur Sichtbarkeitsflag; öffentl. Crates bleiben streng)
+private = { ignore = true }
 
 [bans]
 multiple-versions = "warn"
@@ -16,3 +46,19 @@ wildcards = "deny"
 deny = []
 skip = []
 skip-tree = []
+
+# Optional: Quellen-Policy (nur crates.io und Git mit Pinnen zulassen)
+[sources]
+unknown-registry = "deny"
+unknown-git = "deny"
+allow-registry = ["https://github.com/rust-lang/crates.io-index"]
+allow-git = []
+
+# Lizenz-Mapping/Exceptions für verbreitete Kombis (nur falls nötig):
+[[licenses.exceptions]]
+name = "ring"
+allow = ["MIT", "ISC", "OpenSSL"]
+
+[[licenses.exceptions]]
+name = "openssl"
+allow = ["Apache-2.0", "OpenSSL"]
diff --git a/hauski-stack.md b/hauski-stack.md
index a07f07b9..1376b8b4 100644
--- a/hauski-stack.md
+++ b/hauski-stack.md
@@ -63,7 +63,7 @@ hauski/
 
 ## 3) APIs, Policies, Modelle
 
-* **Chat (MVP):** `POST /v1/chat` (stub → `501 Not Implemented`, OpenAI-kompatible Routen folgen)
+* **Chat (MVP):** `POST /v1/chat` → nutzt `ChatCfg` + Ollama-Upstream; setzt `HAUSKI_CHAT_UPSTREAM_URL` (+ optional `HAUSKI_CHAT_MODEL`), sonst `503` mit `Retry-After` (siehe `crates/core/tests/chat_unconfigured.rs`)
 * **Spezial:** `POST /asr/transcribe`, `/obsidian/canvas/suggest`, `/code/pr/draft`, `/audio/profile`
 * **Policies:**
 
diff --git a/justfile b/justfile
index bd512c1a..7c86f80e 100644
--- a/justfile
+++ b/justfile
@@ -158,3 +158,5 @@ reviewd-enable:
 
 reviewd-status:
     systemctl --user status hauski-reviewd.timer hauski-reviewd.service || true
+run-local:
+    bash scripts/hauski-run.sh
diff --git a/scripts/ci-smoke-chat.sh b/scripts/ci-smoke-chat.sh
new file mode 100755
index 00000000..ab8bd01f
--- /dev/null
+++ b/scripts/ci-smoke-chat.sh
@@ -0,0 +1,66 @@
+#!/usr/bin/env bash
+set -Eeuo pipefail
+IFS=$'\n\t'
+
+ROOT="$(git rev-parse --show-toplevel)"
+LOG_CORE="${ROOT}/target/smoke-core.log"
+LOG_MOCK="${ROOT}/target/smoke-mock.log"
+MODEL="${MODEL:-mock-model}"
+
+cleanup() {
+  set +e
+  [[ -n "${CORE_PID:-}" ]] && kill "${CORE_PID}" 2>/dev/null || true
+  [[ -n "${MOCK_PID:-}" ]] && kill "${MOCK_PID}" 2>/dev/null || true
+}
+trap cleanup EXIT
+
+mkdir -p "${ROOT}/target"
+
+echo "[smoke] start mock-ollama…"
+python3 "${ROOT}/scripts/mock_ollama.py" >"${LOG_MOCK}" 2>&1 &
+MOCK_PID=$!
+
+echo "[smoke] wait mock /api/tags…"
+for i in {1..50}; do
+  if curl -fsS "http://127.0.0.1:11434/api/tags" >/dev/null; then break; fi
+  sleep 0.1
+  [[ $i -eq 50 ]] && { echo "mock did not start"; tail -n +200 "${LOG_MOCK}" || true; exit 1; }
+done
+
+export HAUSKI_CHAT_UPSTREAM_URL="http://127.0.0.1:11434"
+export HAUSKI_CHAT_MODEL="${MODEL}"
+
+echo "[smoke] build & run hauski core…"
+cargo build -q -p hauski-cli
+"${ROOT}/target/debug/hauski-cli" serve >"${LOG_CORE}" 2>&1 &
+CORE_PID=$!
+
+echo "[smoke] wait /health…"
+for i in {1..100}; do
+  if curl -fsS "http://127.0.0.1:8080/health" >/dev/null; then break; fi
+  sleep 0.1
+  [[ $i -eq 100 ]] && { echo "core did not start"; tail -n +200 "${LOG_CORE}" || true; exit 1; }
+done
+
+echo "[smoke] check /health"
+curl -fsS "http://127.0.0.1:8080/health" | grep -qi "ok"
+
+echo "[smoke] check /v1/chat"
+RESP="$(curl -sSf -X POST "http://127.0.0.1:8080/v1/chat" \
+  -H 'Content-Type: application/json' \
+  -d '{"messages":[{"role":"user","content":"Ping?"}]}' )"
+
+python3 - "$RESP" "$MODEL" <<'PY'
+import json, sys
+resp, model = sys.argv[1], sys.argv[2]
+payload = json.loads(resp)
+if payload.get("model") != model:
+    print("unexpected model:", payload.get("model"), "expected:", model)
+    raise SystemExit(1)
+content = payload.get("content","")
+if "(mock)" not in content:
+    print("unexpected content:", content)
+    raise SystemExit(1)
+PY
+
+echo "[smoke] success."
diff --git a/scripts/hauski-run.sh b/scripts/hauski-run.sh
new file mode 100755
index 00000000..b06a7c91
--- /dev/null
+++ b/scripts/hauski-run.sh
@@ -0,0 +1,77 @@
+#!/usr/bin/env bash
+set -Eeuo pipefail
+IFS=$'\n\t'
+
+# HausKI Local Runner
+# - prüft/liest Upstream (Ollama) + Modell aus ENV oder configs/flags.yaml
+# - räumt Port 8080
+# - startet hauski-cli im Vordergrund (Logs: ~/hauski-api.log)
+
+REPO_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")/.." && pwd)"
+LOG="${HOME}/hauski-api.log"
+FLAGS_FILE="${REPO_DIR}/configs/flags.yaml"
+
+err(){ printf "\033[1;31m[err]\033[0m %s\n" "$*" >&2; exit 1; }
+inf(){ printf "\033[1;34m[info]\033[0m %s\n" "$*"; }
+
+command -v curl >/dev/null 2>&1 || err "curl wird benötigt, aber nicht gefunden"
+
+# --- 1) Upstream & Modell ermitteln (ENV > flags.yaml > Defaults) ---
+URL="${HAUSKI_CHAT_UPSTREAM_URL:-}"
+MODEL="${HAUSKI_CHAT_MODEL:-}"
+
+# aus flags.yaml ziehen, wenn ENV leer
+if [[ -z "${URL}" && -f "${FLAGS_FILE}" ]]; then
+  URL="$(awk -F': *' '/^chat_upstream_url:/ {print $2}' "${FLAGS_FILE}" | tr -d '"' || true)"
+fi
+if [[ -z "${MODEL}" && -f "${FLAGS_FILE}" ]]; then
+  MODEL="$(awk -F': *' '/^chat_model:/ {print $2}' "${FLAGS_FILE}" | tr -d '"' || true)"
+fi
+
+# konservativer Default für URL; Modell lieber explizit
+URL="${URL:-http://127.0.0.1:11434}"
+[[ -n "${MODEL}" ]] || err "Kein Modell gesetzt. Exportiere HAUSKI_CHAT_MODEL oder setze 'chat_model:' in ${FLAGS_FILE}"
+
+inf "Upstream: ${URL}"
+inf "Modell:   ${MODEL}"
+
+# --- 2) Ollama prüfen und Modell bereitstellen ---
+if ! curl -fsS "${URL%/}/api/tags" >/dev/null 2>&1; then
+  inf "Ollama scheint nicht zu laufen – versuche Systemdienst zu starten…"
+  if command -v systemctl >/dev/null 2>&1; then
+    if ! systemctl is-active --quiet ollama; then
+      sudo systemctl start ollama || true
+    fi
+  fi
+  sleep 1
+fi
+curl -fsS "${URL%/}/api/tags" >/dev/null 2>&1 || err "Kein Kontakt zu ${URL}. Läuft Ollama?"
+
+if command -v ollama >/dev/null 2>&1; then
+  if ! ollama show "${MODEL}" >/dev/null 2>&1; then
+    inf "Pull ${MODEL}…"
+    ollama pull "${MODEL}"
+  fi
+fi
+
+# --- 3) Port 8080 freiräumen ---
+if command -v lsof >/dev/null 2>&1; then
+  PIDS="$(lsof -ti:8080 || true)"
+else
+  PIDS="$(ss -lntp | awk '/:8080 /{print $NF}' | sed -E 's/.*pid=([0-9]+).*/\1/' || true)"
+fi
+if [[ -n "${PIDS:-}" ]]; then
+  inf "Räume 8080 (kill ${PIDS})…"
+  kill ${PIDS} 2>/dev/null || true
+  sleep 1
+  kill -9 ${PIDS} 2>/dev/null || true
+fi
+
+# --- 4) Starten ---
+cd "${REPO_DIR}"
+export HAUSKI_CHAT_UPSTREAM_URL="${URL}"
+export HAUSKI_CHAT_MODEL="${MODEL}"
+inf "Starte HausKI… (Logs: ${LOG})"
+RUST_LOG="${RUST_LOG:-info,hauski_core=debug}" \
+  cargo run -p hauski-cli -- serve 2>&1 | tee -a "${LOG}"
+
diff --git a/scripts/mock_ollama.py b/scripts/mock_ollama.py
new file mode 100755
index 00000000..52bd6fe9
--- /dev/null
+++ b/scripts/mock_ollama.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+# Minimaler Ollama-Mock (Stdlib):
+#  GET  /api/tags  -> {"models":[{"name":"llama3:8b"}]}
+#  POST /api/chat  -> {"message":{"content":"(mock) <echo>" }}
+import json, sys
+from http.server import HTTPServer, BaseHTTPRequestHandler
+
+HOST = "127.0.0.1"
+PORT = 11434
+
+class Handler(BaseHTTPRequestHandler):
+    def _send(self, code:int, body:dict):
+        data = json.dumps(body).encode("utf-8")
+        self.send_response(code)
+        self.send_header("Content-Type", "application/json")
+        self.send_header("Content-Length", str(len(data)))
+        self.end_headers()
+        self.wfile.write(data)
+
+    def do_GET(self):
+        if self.path.startswith("/api/tags"):
+            self._send(200, {"models":[{"name":"llama3:8b"}]})
+        else:
+            self._send(404, {"error":"not found"})
+
+    def do_POST(self):
+        if self.path.startswith("/api/chat"):
+            length = int(self.headers.get("Content-Length","0"))
+            raw = self.rfile.read(length) if length > 0 else b"{}"
+            try:
+                payload = json.loads(raw.decode("utf-8"))
+            except Exception:
+                payload = {}
+            content = "(mock) ok"
+            for m in (payload.get("messages") or [])[::-1]:
+                if m.get("role") == "user":
+                    content = "(mock) " + str(m.get("content","")); break
+            self._send(200, {"message":{"content":content}})
+        else:
+            self._send(404, {"error":"not found"})
+
+def main():
+    print(f"mock-ollama listening on http://{HOST}:{PORT}", file=sys.stderr)
+    HTTPServer((HOST, PORT), Handler).serve_forever()
+
+if __name__ == "__main__":
+    main()
